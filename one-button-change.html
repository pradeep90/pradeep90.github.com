<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/png" href="./images/favicon-32x32.png" sizes="32x32" />
	<link rel="icon" type="image/png" href="./images/favicon-16x16.png" sizes="16x16" />
        <title>One-Button Change - SPK's Rationality Essays</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/highlight.css" />

	<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
	<!-- <script type="text/javascript" src="/js/header-links.js"></script> -->
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<link href="atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed" />

	<!-- Google Analytics stuff -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-51321929-1', 'pradeep90.github.io');
	  ga('send', 'pageview');

	</script>

    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Rationality Essays</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./notes.html">Notes</a>
                <!-- <a href="/about.html">About</a> -->
                <a href="./archive.html">Archive</a>
		<a href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
            </div>
        </div>

        <div id="content">
          <h1 id="post-title">One-Button Change</h1>

            <!-- <center><img src="https://fbcdn-sphotos-d-a.akamaihd.net/hphotos-ak-prn1/t31.0-8/p600x600/10257116_10202295769100492_2438594605053717342_o.jpg" height="400" width="300" class="sujeet-pic" alt="Sujeet pic" /></center> -->

<h1 id="one-change-at-a-time">One Change at a Time</h1>
<p>Hypothesis: We get evidence about our program by running it on some input or by type-checking it.</p>
<p>Hypothesis: We can process evidence about one variable at a time. Beyond that, we get confused.</p>
<p>(Yes, we can get lucky with multiple changes, but that won’t pay off on average.)</p>
<p><strong>Hypothesis</strong>: One key factor in programming efficiently - aka processing evidence about our program - is to make one high-level change at a time before you get evidence.</p>
<p>This means that you should be able to choose between your two design choices, say process scheduler A and process scheduler B with just one small change. No changing variable assignments in three different places, not hasty commenting of 15 lines of code, no tweaking of multiple configuration files - just one button press.</p>
<p>(Why would this weird condition help write programs faster? We’ll see.)</p>
<h1 id="how-to-program-with-one-button-changes">How to Program with One-Button Changes</h1>
<p>How will this affect the way you code?</p>
<p>For one, you can’t change multiple lines of code within some other function. Because then, if you wanted to roll back those changes, you would have to edit multiple lines.</p>
<p><strong>Corollary</strong>: Any change you make must be encapsulated within a new function before you run the program.</p>
<p>Now, what if you wanted to switch from scheduler A to scheduler B? Sure, A is within a function that you can comment out (or in a class method that you can change at runtime via polymorphism). But B could be a bunch of lines of code strewn across your project. So, to switch to B, you would have to uncomment all those lines. Not allowed.</p>
<p><strong>Corollary</strong>: Any alternatives must be easily switchable (when you run the program).</p>
<p>In OOP, you would do this via interfaces or inheritance, where you simply switch the class that is implementing the interface, and the caller code is none the wiser. In functional programming, you simply switch to another value of the same type or type class.</p>
<p>What happens when you’re starting out with a new feature, like pipes in an operating system (completely hypothetical example; not related to my coursework at all)? If you press the button, you will switch to your neatly encapsulated function or class that implements pipes. But what if you want to go back to a pipe-less operating system, just to check for correctness or performance? You may not be able to, if you have pipe initialization and destruction code lying around, and if processes have information about pipes they may own.</p>
<p><strong>Corollary</strong>: You must have a default alternative for every choice (when you run the program).</p>
<p>For example, if you implemented pipes, your default would be the non-piped version. (Again, you should be able to switch between these two in one button-press.) If you implemented a new time-share scheduler for the operating system, you must encapsulate the original scheduler as a default alternative.</p>
<p>Likewise, if you’re setting out on a “complex” change, you should have a default stub of it that does nothing.</p>
<h1 id="empty-inside">Empty Inside</h1>
<p>Question: What if you’re not creating alternatives, like two types of schedulers, but rather just one algorithm, like pipes for an operating system?</p>
<p>Question: What kind of change are you making at each point? What was the program like earlier and what is it like after the change?</p>
<p><strong>Hypothesis</strong>: You should have a default stub that has the <em>same type</em> as your final code, but doesn’t affect the behaviour of the system. Then, you should have a one-button change that allows you to switch to the final code.</p>
<p><strong>Corollary</strong>: Your unit test for a feature should <em>fail</em> when you switch to the default implementation and <em>pass</em> when you switch to the feature-filled implementation. As usual, it should be a one-button change.</p>
<p><strong>Hypothesis</strong>: Add unit tests (or assert contracts) for everything that your new feature changes.</p>
<p>Hypothesis: Having a one-button change between feature and no-feature allows you to roll it back quickly to see what was caused by the feature itself as opposed to the earlier code.</p>
<p>For example, my test for pipe deletion passed even though my <code>pipdelete</code> function was empty! I’d mixed up types in other places, which meant that my desired pipes were not getting initialized in the first place. So, the test passed whether or not I implemented my <code>pipdelete</code> feature. Good to know. Otherwise, I’d be scratching my head wondering which of my seven changes in different parts of the system had caused the bug.</p>
<h1 id="upshot">Upshot</h1>
<p>What do all those straitjackets get you? I’m not fully sure. We’ll find out the usual way: good ol’ fashioned experimentation.</p>
<p><strong>Hypothesis</strong>: Single, easily-reversible change -&gt; any behaviour that is in the program with the feature on and not in the program with the feature off must be caused (at least partly) by the feature.</p>
<p>Contrast that to shotgun change, where you aren’t sure which change broke your code.</p>
<p>Hypothesis: First-class objects -&gt; make it easier to switch.</p>
<p>For example, a value or function or object of the same type.</p>
<p>Question: Do you really need to rollback that often? Yes, you will want to toggle a new feature while implementing it. But after implementing A, B, and C in sequence, will you need to check out AB’C? Or will you treat the existing program as correct and indivisible?</p>
<p><strong>Observation</strong>: Will need to rollback if you think of a test or find a bug after the implementation.</p>
<p>Hypothesis: Hard to come up with good tests or properties in advance.</p>
<p>Hypothesis: If you come up with a test or property in the future, you need to toggle back through your features to see when it stops passing.</p>
<h1 id="multiple-possible-causes-are-hard-to-reason-about">Multiple Possible Causes are Hard to Reason About</h1>
<h2 id="intermediate-states-are-hard-to-reason-about">Intermediate States are Hard to Reason about</h2>
<p>Observation: Suppose you had to do a number of things to reset a system. You could miss a step or two and land up with “weird” behaviour.</p>
<p><strong>Hypothesis</strong>: Multiple changes when trying to go to a desired state -&gt; could leave the system in a state that is “hard to reason about”.</p>
<p>For example, you need electricity, intact wires, a working bulb, and a switch in the ON state to make a light bulb glow. If however, there’s a problem with the bulb or if you forgot to pay your electricity bills, the bulb won’t glow. But you don’t know exactly what caused the problem.</p>
<h2 id="minimize-number-of-possible-causes">Minimize Number of Possible Causes</h2>
<p>Observation: The problem is that you can’t <em>identify</em> the possible causes. You become highly uncertain.</p>
<p><strong>Hypothesis</strong>: “Processing evidence” = figuring out which states of the system could have caused the given output.</p>
<p>This is what Bayes theorem talks about.</p>
<p><strong>Hypothesis</strong>: Humans can’t handle a bunch of possible causes leading to the same output.</p>
<p>(That’s why they lump them in the same category.)</p>
<p>Hypothesis: Humans like to toggle one variable at a time because they can’t handle it if one of several things could have caused the output.</p>
<p>Observation: When there’s a lot of stuff that we’ve changed about a system and the output is not anything we can normally explain, we consider the system “messy” or “chaotic”.</p>
<p><strong>Hypothesis</strong>: “Chaotic mess” = can’t tell which state caused the given output (because there are too many of them).</p>
<p>Classic example: when I changed a bunch of scheduler code and couldn’t tell where the bug was.</p>
<p><strong>Hypothesis</strong>: Aim of category design = <em>minimize</em> the number of possible causes of any outcome.</p>
<p>For example, test if there’s electricity at the bulb socket. Then, try to plug in the bulb. If there was no electricity initially, then the earlier part of the system is broken. If there is electricity and if the bulb works, then there’s no problem. If it doesn’t, then we know that the bulb is what is broken.</p>
<h2 id="debugging">Debugging</h2>
<p>Hypothesis: Aim of programming: Fix undesirable output.</p>
<p>Fixing undesirable output would involve figuring out its cause and then changing it. The problem arises when you can’t figure out the cause of some undesirable behaviour.</p>
<p><strong>Hypothesis</strong>: Debugging = figuring out the <em>cause</em> of some undesirable behaviour.</p>
<p><strong>Hypothesis</strong>: We spent a lot of time, maybe most of our time, in debugging.</p>
<p>Observation: Why do I feel low in confidence sometimes? Don’t quite know. Is it mostly because I haven’t exercised or because I’m not focusing on the topics I care about or don’t have a “great” social life? Don’t know. I’m not able to do backward inference on my social performance.</p>
<h2 id="break-the-output-into-pieces">Break the Output into Pieces</h2>
<p>Hypothesis: To find out the cause of some output, break it into pieces according to known causes and thus narrow down the culprits.</p>
<p>For example, if you know that the output list was mapped from some input list, then an error in the 5th element must have been due to the 5th element of the input list.</p>
<h2 id="backward-inference">Backward Inference</h2>
<p><strong>Hypothesis</strong>: This is backward inference.</p>
<p>And it’s hardest when you have made a lot of changes before observing some understandable output. For example, when working on my OS assignment, I changed the scheduling code in a lot of places and then ran my test case. The OS hung after the initial output. Why? I had no clue.</p>
<p>Observation: This is what House does. He look at symptoms and infers the diseases that could have caused them. (Fictional evidence, but representative of doctors who do, in fact, diagnose patients.)</p>
<p>Laymen or even his fellow doctors are often puzzled by the same observations. (Fictional evidence.)</p>
<p>Observation: Mystery-solving (a la Hercule Poirot or Sherlock) is all about backward inference.</p>
<h2 id="strong-evidence">Strong Evidence</h2>
<p>Hypothesis: Strong evidence = something that tells you the cause is in <em>this</em> part of the system, not that one.</p>
<p>This is what we desire. We want to narrow down the suspects.</p>
<p><strong>Hypothesis</strong>: If you can switch easily (and reliably) between two alternatives, you can observe the difference in output, and thus figure out where the cause lies.</p>
<p>Question: What if you could run the program only once? How could you design your program to minimize the number of possible causes?</p>
<p><strong>Question</strong>: What sort of test cases should you design so that you get discerning output?</p>
<h2 id="how-do-we-build-a-system-forward-backward-inference">How do we Build a System? Forward + Backward Inference</h2>
<p><strong>Hypothesis</strong>: We want our system to have some target property. So, we change some variables in the hope of hitting the target property. Then, we observe the actual output and infer which variables we should have changed differently. And so it goes.</p>
<p>It’s forward inference to compute the actual output (which the computer automates for us, in the case of programming) and backward inference to figure out which variables we need to change further.</p>
<p>Hypothesis: The problem, of course, is when you have a lot of other variables in between.</p>
<p>For example, I just wanted to change the scheduling algorithm of the XINU OS. It was a simple enough conceptual change, but because my change affected a lot of other variables (like whether interrupts were disabled or enabled, polled I/O vs blocking I/O, null pointer errors, etc.) I couldn’t tell exactly which of my changes had caused what.</p>
<h2 id="unit-tests-minimize-number-of-causes">Unit Tests minimize Number of Causes</h2>
<p>Hypothesis: Unit tests minimize number of causes because their output depends only on one function or class.</p>
<h1 id="big-functions-are-hard-to-reason-about-too">Big Functions are Hard to Reason about too</h1>
<p>Observation: Bunch of journal notes and essays. Don’t know exactly what they contain or what they advise for some problem I face. Clearly, a “chaotic mess”.</p>
<p>Observation: Unfamiliar function - can’t tell what it does.</p>
<p>Observation: If I have a variable that I can change to switch the scheduler from a time-share scheduling algorithm to a proportional-share algorithm, then I can kind of tell the difference in behaviour between the two.</p>
<p>Observation: But if I have three hundred lines of code spread over four files that are different between time-share and proportional-share scheduling algorithms, I find it much harder to predict the differences in behaviour.</p>
<p><strong>Hypothesis</strong>: Lots of possible input states and thus lots of possible output states -&gt; hard to infer forward or backward.</p>
<p>Why? Not quite sure. But if it’s an arbitrary function, then you have a lot of input-output mappings to remember. You’re liable to give up.</p>
<h1 id="restricting-yourself-to-one-button-changes-simplifies-your-model">Restricting yourself to One-Button Changes simplifies your Model</h1>
<p>Hypothesis: One-button change between alternatives -&gt; simpler type signature (A vs B -&gt; X vs Y).</p>
<p>Corollary: You won’t be able to make low-level predictions about, say, the exact priority of each process at each point of time, but you would be able to predict the high-level properties (such as, I/O-bound processes will go first in a time-share scheduler).</p>
<p>Corollary: One-button change between small set of high-level alternatives -&gt; <strong>cannot</strong> choose some arbitrary intermediate state.</p>
<p>Corollary: So, the output will always be that corresponding to one of the high-level alternatives. Much easier to infer forward or backward.</p>
<p><strong>Hypothesis</strong>: Allow yourself only one-button changes vs can change anything anywhere -&gt; far simpler model of the system vs lots of possible inputs and lots of possible outputs.</p>
<p>You’re restricting your set of possible interventions. Because you know you haven’t changed anything else anywhere, the only possible inputs are those defined by your high-level categories.</p>
<p>Hypothesis: Allow yourself only one-button changes -&gt; fewer possible interventions and thus fewer possible input states.</p>
<p><strong>Hypothesis</strong>: Number of possible interventions -&gt; number of categories.</p>
<p><strong>Hypothesis</strong>: Number of categories -&gt; number of possible input-output mappings -&gt; number of possible causes for any output and number of possible outputs for any cause.</p>
<h1 id="tests">Tests</h1>
<p>Observation: I have one test for each condition mentioned in the spec.</p>
<p>For example, “In any case, if the arguments are invalid, the pipe was already connected to other processes, or the state of the pipe does not permit connection, the system call returns SYSERR.” I have a test for each of them.</p>
<p><strong>Observation</strong>: Red-green saves my ass. I keep forgetting to add my new test case to the test list, and so it seems like the test has passed. Only when I make it <em>fail</em> do I realize my mistake.</p>
<p><strong>Hypothesis</strong>: To be sure that some output property is caused by your feature, toggle it and see whether the property toggles too.</p>
<p><strong>Observation</strong>: Tests bring out bugs that I would never have inferred.</p>
<p>For example, deleting a pipe caused a pipe to be in a non-active state when calling disconnect on the writer. Who knew?</p>
<p><strong>Hypothesis</strong>: How to write tests - look at the interface alone and analyze the different possible inputs.</p>
<p>For example, <code>pipe_disconnect_reader</code> cares only about the different states of the pipe (free, used, connected, writer disconnected, etc.), not about the rest of the system.</p>
<h1 id="handle-all-possible-high-level-inputs">Handle all possible High-level Inputs</h1>
<p><strong>Hypothesis</strong>: To be confident that you’ve written your function correctly, handle all the high-level categories of your input.</p>
<p>Corollary: Errors crop up when you omit some cases.</p>
<p>The most obvious case is forgetting to check for NULL. Another case is to handle all possible states of your input argument, like a pipe that is not connected to anything or a pipe that has been freed.</p>
<p>Corollary: Static type-checking helps you by making sure you handle all the possible input values, especially in the case of sum types like in Haskell.</p>
<p><strong>Corollary</strong>: You must yourself know what must happen for each input configuration.</p>
<p><strong>Lesson</strong>: Write your code one branch at a time. Write a unit test up-front to make sure you’re actually adding a feature.</p>
<p>You should change code only within one of the possible input categories. If you want to do something for input A, you must do something (maybe a dummy default action) for inputs B and C.</p>
<p>Corollary: That way, at each point, you can tell which value was caused by the branch for A and which one by the branch for B.</p>
<h2 id="what-is-the-next-unit-test">What is the Next Unit Test?</h2>
<p>Hypothesis: If you’re stuck, ask yourself what is the next unit test you want to pass.</p>
<h1 id="work-needed-is-proportional-to-number-of-test-cases">Work Needed is proportional to number of Test Cases</h1>
<p>Corollary: The total work you need to do depends on the number of branches you need to implement and the time it takes you to code and test each branch.</p>
<p>Observation: I didn’t even <em>know</em> how many branches I had to deal with. I couldn’t see them in my head when I thought about the problem of “implementing pipes for XINU”.</p>
<p>Corollary: Number of branches you had to implement = number of test cases.</p>
<p>So, use the test cases to determine the total work you had to do.</p>
<p>Corollary: Number of test cases is determined by the number of branches you need to implement. Make sure you have that many.</p>
<p>Hypothesis: If we assume that the time needed to make one unit test pass is constant, then the estimated time for the whole project should be proportional to the number of branches in each function (i.e., the number of test cases).</p>
<p>We can use that to estimate time needed.</p>
<h2 id="planning-fallacy">Planning Fallacy?</h2>
<p>Observation: I underestimated the number of test cases I would need to implement. Sometimes, I was so unsure that I needed to have unit tests for smaller things like adding a semaphore to my pipe entry, because I’d not used it before.</p>
<p>Observation: I didn’t even know what output I wanted from some function.</p>
<h1 id="callers-define-your-contract">Callers define your Contract</h1>
<p>Observation: Hard to change the behaviour of <code>pipe_set</code> without knowing how and where it’s been used. I don’t want to break its “contract”.</p>
<p>Hypothesis: If you had unit tests (and an assertion-based contract), you could just use that as your contract and change whatever you wanted as long as you didn’t break it.</p>
<h1 id="why-you-need-to-roll-back-sometimes">Why you Need to Roll Back Sometimes</h1>
<p>Observation: Error when trying to create a semaphore. No clue why.</p>
<p>Experiment: Didn’t change anything in the lower-level functions. Just toggled the high-level tests to see which combination broke it.</p>
<p>For example, I knew that running the 20 tests gave the error. Running 0 tests didn’t give the error. Running the first 10 didn’t either. Turned out running two particular tests together gave the error. Cool. That narrowed it down. (I was able to find out that I was initializing too many semaphores and thus running out.)</p>
<p>Imagine if I’d tried this without the high-level functions and had made changes here and there. I would have been overwhelmed within a few minutes. Guess how I know that? Because that’s what I started out doing. Only after half an hour or so did I wise up.</p>
<p><strong>Hypothesis</strong>: Need to roll back and toggle features when you have errors across functions.</p>
<p>Unit tests catch errors that are within a single function. For errors across functions, you need high-level toggling.</p>
<h1 id="backward-inference-1">Backward Inference</h1>
<p><strong>Hypothesis</strong>: This is how you do backward inference. You narrow down some combination of high-level causes and test them till you find one whose effect matches the observed output. After, that you narrow it down at the next level, thus keeping the “complexity” or number of possible causes limited at all times.</p>
<p>Observation: The key was that turning on all the high-level causes on gave you a positive answer (error) and turning them all off gave you a negative answer (no error). So, you could tell that the error must begin with some combination of causes between zero and everything.</p>
<h1 id="which-input-configuration-did-i-fail-to-handle">Which Input Configuration did I Fail To Handle?</h1>
<p>Observation: Notice that I didn’t exactly break any of my older unit tests. What I broke was the underlying code (<code>pipinit</code>), which was exacerbated by the fact that I ran so many tests and ended up creating too many semaphores.</p>
<p>Observation: I added a new property to the program (semaphores), which caused problems.</p>
<p>Observation: I failed to ensure the property that the program used only a limited set of semaphores.</p>
<p>Question: Where could I have checked for that property?</p>
<p>Well, the number of semaphores created would be proportional to the number of times <code>pipinit</code> was called, which I assumed was just once during system initialization. Turned out that <code>pipdelete</code> also called <code>pipinit</code>. As did my test setup function (when trying to reset all pipes).</p>
<p>Observation: It’s simple. I should have handled the case where <code>semcreate</code> returns SYSERR. That’s all. That’s how stupid my mistake was. Cost me a full hour spent scratching my head.</p>
<p><strong>Hypothesis</strong>: Bug -&gt; ask “which input configuration did I fail to handle?”.</p>
<p>Observation: This would never have happened in Haskell. It would have given me a <code>Maybe Semaphore</code>, whose <code>Nothing</code> case I would be forced to handle.</p>
<p>Lesson: In particular, look closely at the input type you’re getting.</p>
<p>For example, in <code>pipe_disconnect_writer</code>, instead of worrying about all the possible states that the rest of the system can be in, I should look at just the input pipe. It can be in a free, used, or connected state. If I handle all three cases faithfully, I’ve done my job. Nothing else to worry about.</p>
<p>Observation: The reader process could be in a waiting state when somebody disconnects it. So, I have to handle the different process states too.</p>
<p>Observation: I don’t know what to do in the various cases there.</p>
<h1 id="look-at-properties-of-your-own-input-not-of-other-functions">Look at Properties of your own Input, not of Other Functions</h1>
<p>Observation: Have to look at callers of <code>pipe_disconnect_writer</code> because I’m not sure if there can ever be a case where the reader disconnects first and leaves writer calling disconnect later.</p>
<p>Actually, I don’t have to. I can see that <code>pipe_disconnect_reader</code> always leaves writer disconnected. If the pipe to reader was in the PIPE_CONNECTED state, it would disconnect writer. Else, writer would have already been disconnected. Inference!</p>
<p>Hypothesis: I suspect I could avoid writer having to look through reader’s code by checking the invariants on pipe itself.</p>
<p>Pipe doesn’t even have a state for “reader disconnected but writer not yet disconnected”. That’s it. End of story.</p>
<p><strong>Hypothesis</strong>: A function shouldn’t need to look at the innards of other functions to decide what to do. It should just look at its inputs, their properties, and its own desired output properties.</p>
<h1 id="processing-evidence">Processing Evidence</h1>
<p>Question: What kinds of observations do I have to process?</p>
<p>For example, let’s consider each operation of the kind “ABCD -&gt; X and ABC’D’ -&gt; X implies that C and D probably don’t cause X” to be a single cognitive step. (I think we process that kind of stuff really quickly.)</p>
<p>Question: So, how many such operations do I have to run (for a given number of branches)?</p>
<h1 id="lost-track">Lost Track</h1>
<p>Observation: Got stuck debugging a stupid return value error. Lost track of what my original aim was.</p>
<p>One change at a time.</p>
<h1 id="debugging-principles">Debugging Principles</h1>
<p>Hypothesis: You need to have a really small test case.</p>
<p>My mistake with the scheduler was that I was working with a six processes all running at the same time doing god-knows-what. How are you supposed to debug that efficiently?</p>
<p>Observation: Not able to interpret the debugging output because there are too many printf statements and I don’t know what came from where.</p>
<p>Observation: Narrowed it down by toggling the high-level function calls. Things look much clearer. I know that the output is coming from a given two lines.</p>
<p>Observation: Narrowed it even further. Check only the semaphore part.</p>
<p>Observation: Right now, things “aren’t straight” in my head. I don’t know which configurations I’ve handled and which ones I haven’t. So, I don’t feel like I can reason about the behaviour of the program.</p>
<p><strong>Hypothesis</strong>: Know which inputs configurations you’ve handled and which not -&gt; feel confident about the behaviour of the program.</p>
<p><strong>Hypothesis</strong>: Notice what changes you’ve made. Any change in behaviour is due to a change you’ve made.</p>
<p>So, look at your diff from the previous state.</p>
<p><strong>Lesson</strong>: The moment you get an error, toggle back to a working state and then look at the differences.</p>
<h1 id="duplication-leads-to-more-input-configurations">Duplication Leads to More Input Configurations</h1>
<p>Observation: The official code had a state field that could take the value <code>PIPE_CONNECTED</code>, etc. However, that was strongly correlated with the writer and reader semaphore being free or not-free. So, I may have to consider multiple input configurations that actually mean the same thing.</p>
<p><strong>Hypothesis</strong>: Code duplication -&gt; more input configurations that give the same output but which you have to handle separately in case they are given inconsistently.</p>
<p>For example, I would have to flag an error in the case where the variable says <code>PIPE_CONNECTED</code> but the semaphores are actually free. Unnecessary headache.</p>
<p>Corollary: What’s more, when you finally merge those redundant input states, you’ll have to do a lot of careful work to remove the separate if-cases.</p>
<h1 id="truly-pure-functions">Truly Pure Functions</h1>
<p>Observation: Right now, some of my unit tests depend on more than one function. For example, testing disconnect depends on the correct behaviour of “connect”.</p>
<p>Hypothesis: Pure functions won’t be like that. You can genuinely test their input configurations alone.</p>
<p>Observation: But disconnect will still call pipe-related functions like reset or set writer or whatever.</p>
<p><strong>Hypothesis</strong>: Either your higher unit tests will test multiple functions or you will have to use equational reasoning.</p>
<h1 id="abstract-types-reduce-the-number-of-input-configurations">Abstract Types reduce the number of Input Configurations</h1>
<p>Question: How can we reduce the time taken to implement some features?</p>
<p>Observation: Time taken seems to depend on the number of test cases (aka input configurations) and the time taken to pass each test case.</p>
<p><strong>Hypothesis</strong>: Abstract types reduce the number of input configurations and thus reduce the number of tests.</p>
<p>For example, <code>sortInts :: [Int] -&gt; [Int]</code> has way more configurations than the generic <code>sort :: Ord a =&gt; [a] -&gt; [a]</code>.</p>
<p>Lesson: If you want to code faster, design your types well.</p>
<h1 id="understanding-knowing-the-output-for-each-input-configuration">Understanding = Knowing the Output for each Input Configuration</h1>
<p>Hypothesis: Understanding = knowing the output for each input configuration.</p>
<p>Observation: I keep saying “I don’t understand surrogate endpoints (or some other concept)”. But that doesn’t help me move forward.</p>
<p><strong>Hypothesis</strong>: Say “I don’t understand concept X” -&gt; don’t know how to move forward. Say “I don’t know the output for a particular input type X1” -&gt; can look for resources that give you the output.</p>
<p>For example, I don’t know what happens if you predict for the follow-up study in cancer trials using “principal surrogacy” or using “Prentice’s criterion”. I need to figure that out.</p>
<h1 id="forming-an-technique-to-solve-problems">Forming an Technique to Solve Problems</h1>
<p>Question: How do you come up with a technique to solve, say, the do-calculus problems that you find in exams?</p>
<p><strong>Hypothesis</strong>: Come up with a hypothesis for each input type and test it on the problems you’ve seen (and further problems that you invent).</p>
<h1 id="confidence">Confidence</h1>
<p>Hypothesis: Confidence &lt;- knowing the possible input configurations and then knowing that you’ve handled all of them.</p>
<p>With my journal notes, for example, I don’t know the input configurations for some mechanism I’m trying to figure out (like how we learn) and so I don’t know if I’ve covered everything.</p>
<h1 id="assorted-ideas-todo">Assorted Ideas (TODO)</h1>
<p><strong>TODO</strong>: Composition (<code>pipe_is_writer_semaphore_free = pipe_is_semaphore_free . pipe_writer_semaphore</code>). Should you know the properties?</p>
<p>Duplication is bad because it makes you test essentially the same branch multiple times. For example, <code>pipe_is_writer_semaphore_free</code> and <code>pipe_is_reader_semaphore_free</code> both just call <code>pipe_writer_semaphore</code> with different arguments. But I have to run different tests.</p>
<p><strong>Hypothesis</strong>: When you have roughly the same test for two different functions, you have duplicated some code.</p>
<p>Hypothesis: If two branches give you the same output, merge them.</p>
<p>Hypothesis: Uncertainty &lt;- number of branches because the answer for each of those branches could be something different. You have to know all of the outcomes.</p>
<p>Hypothesis: Duplication -&gt; takes more work to test and more work to understand.</p>
<p><strong>Hypothesis</strong>: It’s a mistake to have duplicate code because you end up doing more work to test your program.</p>
<hr />
<p><strong>Hypothesis</strong>: In deliberate practice (and thinking in general), chunks correspond to the branches of your model.</p>
<p>So, chess grandmasters who have learned 50k chunks have learned 50k different branches of their model of chess.</p>
<p>Hypothesis: There’s a lot of duplication in there. You could probably merge parts of several branches. (Maybe it’s necessary for optimization - because they can recognize formations in a flash.)</p>
<p><strong>TODO</strong>: Figure out how you can represent each chunk - aka branch - as a flashcard, for easy learning.</p>
<h2 id="how-to-abstract">How to Abstract</h2>
<p>Hypothesis: Look at the input and output and merge those input configurations that have the same output. Also look at cases where the output part is a known function of the input.</p>
<h1 id="top-level-interventions-vs-surgical-interventions">Top-Level Interventions vs Surgical Interventions</h1>
<p>Observation: In the scheduler problem, I had to change one part of the system to affect the overall behaviour. In the pipes problem, however, I had full control of my system (since I was coding for the unit tests).</p>
<p>Question: Are they different in kind?</p>
<h1 id="when-there-are-no-readily-available-tests">When There are No Readily Available Tests</h1>
<p>Observation: Writing a research project proposal for a course - don’t know what is good and what isn’t.</p>
<p>Question: How do I get feedback? How do I go about implementing “code” (aka models) to handle different inputs?</p>
<p><strong>Hypothesis</strong>: Causes and effects all the way.</p>
<p>For example, come up with the causes and effects of surrogate endpoints.</p>
<h1 id="make-a-change-only-when-a-test-fails">Make a Change only when a Test Fails</h1>
<p>Observation: Wasted a lot of time just staring at the screen hoping for a “perfect” solution to land in my mind.</p>
<p>Observation: I don’t have near-term tests for the changes I’m making to pipgetc. They are all abstract changes.</p>
<p>Observation: Long time since I ran <em>any</em> test (or even compiled the code). No feedback.</p>
<p><strong>Hypothesis</strong>: Make a change only when a test fails. Duh!</p>
<p>It’s called red-green-refactor. I’ve been making changes willy-nilly.</p>
<p>Corollary: Otherwise, you will end up making blue-sky changes to your code.</p>
<p>Corollary: Don’t have to think about abstract cases. Don’t have to “contemplate the ifs”. Just make the current test case pass.</p>
<p><strong>Hypothesis</strong>: Writing code without a failing test -&gt; don’t know if you’re cutting through.</p>
<p>Corollary: Writing to pass tests -&gt; consequentialism.</p>
<h1 id="interface-possible-input-configurations">Interface = Possible Input Configurations</h1>
<p>Hypothesis: Instead of talking about the “interface” to some program, talk about the different input configurations that it may receive. That, together with the expected output, defines its “interface”.</p>
<p>In other words, talk about the test cases it must satisfy.</p>
<p><strong>Corollary</strong>: Minimal interface = few input branches.</p>
<p>For example, <code>sort :: Ord a =&gt; [a] -&gt; [a]</code> has fewer possible inputs than <code>sortInts :: [Int] -&gt; [Int]</code>.</p>
<h1 id="minimizing-the-outputs">Minimizing the Outputs</h1>
<p>Observation: We’ve seen how to minimize the number of inputs to a function by combining those that produce the same output into the same category.</p>
<p><strong>Hypothesis</strong>: If you can get only a few possible outputs, forbid the other output values.</p>
<p>For example, a function that tells you whether or not a semaphore is free will return either true or false. Capturing that in an Int makes your interface unnecessarily large because the caller would have to assert that the output is either 0 or 1. So, make it a Bool.</p>
<h1 id="testing-a-high-level-function-shouldnt-be-blind">Testing a High-level Function: Shouldn’t be Blind?</h1>
<p>Question: Can you tell how many branches (and thus total test cases) a function will have, based on its type signature?</p>
<p><strong>Hypothesis</strong>: It depends on the definition.</p>
<p>For example, if I write <code>fourthRoot</code> from scratch, I would have to test several inputs cases like 0, 1, -1, 0.01, 4, etc. But if I know that <code>fourthRoot = sqrt &lt;=&lt; sqrt</code>, I feel like things become simpler.</p>
<p>Hypothesis: Number of test cases &lt;- amount of code duplication.</p>
<p>For example, <code>sortInts</code> and <code>sortLists</code> would share most of their code, except for the List- vs Int-handling parts. It would be stupid to test the same quicksort algorithm in both cases. <strong>Corollary</strong>: Amount of duplication among tests =&gt; amount of duplication among their functions. Question: So how would you do it ideally? How to not duplicate tests between <code>sortLists</code> and <code>sortInts</code>?</p>
<p>Hypothesis: The answer would seem to be to extract their common code into <code>sort</code>.</p>
<p>Then, you would write <code>sortLists = sort</code> (or just use sort directly where you would have used sortLists).</p>
<p><strong>Question</strong>: But say you did <code>fourthRoot = sqrt &lt;=&lt; sqrt</code>. What tests should you now write?</p>
<p>Hypothesis: You probably don’t need to check for invalid inputs like -1, etc. because sqrt already does that and returns <code>Nothing</code>.</p>
<p><strong>Corollary</strong>: A tester who insisted on being blind to the code and coming up with “advance predictions” would end up duplicating a ton of work for <code>fourthRoot</code>. Ditto for <code>sortLists</code> and <code>sortInts</code> if he didn’t understand that they used the same sorting algorithm.</p>
<p>Hypothesis: This is why people use type systems, so that they don’t have to duplicate their test code. They can reason about things from the types themselves.</p>
<h2 id="no-ifs-no-tests">No Ifs, No Tests</h2>
<p><strong>Hypothesis</strong>: You need to write unit tests only if you introduce new if-statements.</p>
<p>For example, take <code>f = uniq . sort</code>. Why do you believe that that function will return a sorted list unique elements?</p>
<p>Positive exemplar: When I wrote <code>pipgetc</code>, I had to test the cases where the function was supposed to return <code>SYSERR</code>. They were separate if-conditions in the code.</p>
<p>Hypothesis: Could it depend on the size of the function too?</p>
<p>Hypothesis: You should know the properties of each function in the chain.</p>
<p>For example, if I gave you <code>doSomeMagic . sort</code>, you wouldn’t really know what that function did.</p>
<p><strong>Observation</strong>: Ad hoc if-conditions in each function create exponential number of branches in a function chain.</p>
<p>In contrast, a return type of Maybe monadically composes to give you just two possible outputs at each point in the chain.</p>
<h2 id="when-can-you-chain">When can you Chain?</h2>
<p><strong>Hypothesis</strong>: You can chain together functions when each one “handles” all the possible outputs of the previous one.</p>
<p>For example, <code>uniq</code> handles the empty list and normal list outputs of <code>sort</code>. <code>sqrt</code> handles the Just and Nothing outputs of <code>sqrt</code>.</p>
<p>Corollary: Functions not in a chain -&gt; there could be output configurations you failed to handle.</p>
<p>For example, possible NULL values in C.</p>
<p>Observation: If I were doing pipe functions in a chain, I could be certain that they handled all the intermediate configurations. But since I was writing an imperative function, I didn’t know if I had handled the cases where the pipe became free after a call to wait or got disconnected or whatever.</p>
<h1 id="exams-input-branch-concept-needed">Exams: Input Branch = Concept Needed</h1>
<p>Hypothesis: Input branch = question that I have to answer. Which depends on the concepts needed.</p>
<p>Hypothesis: Input branch = concept needed. I need to have the correct output for each concept. Output = concept definition.</p>
<p>For example, I need to know what a “proper causal path” is, in case they ask for it in the exam.</p>
<h1 id="why-refactor-your-proofs-and-code">Why Refactor your Proofs and Code?</h1>
<p>Hypothesis: Refactor -&gt; find simple solution -&gt; store that as your output for that particular input.</p>
<p>Reuse that solution for other inputs -&gt; learn to recognize that input type based on this technique.</p>
<p>For example, HW2 8(c) took a lot of trial and error for me to find the answer. (Still don’t know if I’ve made a mistake somewhere.) Now, if I cleaned it up and got to the answer in, say, three steps, then I could extract general lessons from that clean solution.</p>
<p><strong>Observation</strong>: Basically, I’m unable to “draw lessons” from a jumble of trial-and-error proof steps.</p>
<p>Why not?</p>
<p><strong>Hypothesis</strong>: I can’t see which parts of the input led to which parts of the output.</p>
<p>So, my current “proof” (more like one page of arrows and scribbles) feels like it pertains only to problem 8(c). I can’t see what I would reuse for a variation of the problem.</p>
<p>Corollary: This is why you need to do proofs over and over till you get a succinct solution. (Ditto for programming.)</p>
<p><strong>Hypothesis</strong>: You need to bring your proof into a form where you can see that if you toggled a high-level variable A, you wouldn’t need to do step 1 anymore. If you toggled B, you wouldn’t need step 2 anymore, and so on.</p>
<p>Why can’t I do that now? The proof is so large and hairy that I can’t imagine the alternative.</p>
<h1 id="confusion">Confusion</h1>
<h2 id="confused-by-the-options">Confused by the Options</h2>
<p>Observation: Still confused (even though I did the proof a few minutes ago).</p>
<p><strong>Hypothesis</strong>: Confusion = don’t know the conditions when you should choose option A vs option B vs option C (in order to reach your target).</p>
<p>For example, I can see that two back-door paths from X to Y are potentially unblocked if I condition on W1 or W2.</p>
<p>What options do I have? I could apply rule 2 on X, rule 3 on X, condition on Z1, condition on W2, condition on W1, or condition on some combination of those 3. Which one should I choose?</p>
<p>Next, if I choose to condition on Z, what should I do? Rule 2 on X, rule 3 on X, rule 2 or Z, rule 3 on Z, condition on W1, etc.</p>
<p>There are tons of options!</p>
<p>Observation: Experts somehow slice through this thicket of options and hone in on the correct one.</p>
<p><strong>Hypothesis</strong>: Given the graph and the desired expression, there is a direct way to come to the correct step <em>without</em> much trial and error.</p>
<p>Observation: There are only three trails from X to Y.</p>
<p>Hypothesis: Maybe there is a simpler way to come to an ID expression without traversing the do-calculus expression tree. Use the trails somehow. (Don’t know how.)</p>
<p><strong>Observation</strong>: Still feels like every step of the proof depends on every other step.</p>
<p>Basically, I’m still traversing the tree by trial and error. If I choose rule 2 on X, then the whole rest of the proof changes (it seems).</p>
<p>Question: Why not try all possible techniques?</p>
<p>Observation: Heavy resistance from my mind when I try to do that.</p>
<p><strong>Hypothesis</strong>: I believe that trial and error is inefficient, so I have zero motivation for doing it. Correct solutions usually lead to the answers directly without much trial and error. That feels like the signature of a good technique, and conversely, trying things blindly feels like the signature of a bad technique.</p>
<p>That seems to have paid off in general. Looking for direct algorithms seems to have been a good heuristic in the past.</p>
<p>Corollary: That also makes me more confused than most, because I’m unwilling to accept trial and error where I can’t see why I’m using some technique, or use a half-cooked understanding of some technique. I need crystal-clear understanding before I take action.</p>
<h2 id="confused-write-a-test">Confused? Write a Test</h2>
<p>Observation: Confused about whether a process waiting on a semaphore will get a return value of SYSERR or OK. Been thinking about it for the last 10 minutes.</p>
<p>Hypothesis: Run a simple test to find out the answer.</p>
<p>Hypothesis: “Confused” = don’t know the output of some branch.</p>
<h2 id="infer-based-on-the-variables-we-focus-on">Infer based on the Variables we Focus on</h2>
<p><strong>Hypothesis</strong>: Which conclusion we come to &lt;- the variables we focus on.</p>
<p>Just focus on one variable, like how awesome romantic life is - feel like a life without romance is worthless. Focus on money and flashy cars and the other stuff rappers rap about - feel like a life without that is a waste.</p>
<p>Focus on more variables - get a more nuanced view. For example, celebrities may get way more compliments than you or me, but they also get a ton more hate. They get judged every single day for things they didn’t or even couldn’t do perfectly.</p>
<p>However, focus on too many variables - try to figure out a building’s architecture in one go (for a novice like me) - fail. Ditto for “complex” do-calculus problems - too much information for me to use.</p>
<p><strong>Hypothesis</strong>: Confusion (one cause) &lt;- focusing on too many variables.</p>
<p><strong>Observation</strong>: I didn’t even know the type signature of “graphical condition” or “definition for surrogate endpoints” (when starting out on my surrogate endpoints project).</p>
<p>So, I took the wrong thing to be a valid “definition for surrogate endpoints” and found out a week later that it wasn’t actually valid.</p>
<p><strong>Hypothesis</strong>: No type signature, lots of variables -&gt; focus on too many variables.</p>
<p>No type signature, some other variables -&gt; accept the wrong answer.</p>
<p>Type signatures -&gt; may not know the answer, but won’t focus on the wrong variables.</p>
<h2 id="ignore-some-variables">Ignore Some Variables</h2>
<p><strong>Corollary</strong>: If you get convinced that all the variables you see are important, you will try to take all of them into account. And because you don’t have any high-level rule that covers a dozen variables at once, you will get “confused”. You won’t know which technique to use.</p>
<p>You could have done much better if you focused on just a few variables you “understood” (i.e., for whose configuration you knew how to respond).</p>
<p>Lesson: Sometimes, it’s best to reduce the number of variables you focus on. (When?)</p>
<h2 id="case-study-edge-of-tomorrow">Case Study: Edge of Tomorrow</h2>
<p>Observation: Cage drops into the battlefield. No clue what to do. There are missiles flying every way, people fighting here and there, aircrafts exploding above. What to do for this input configuration? Turn left or right? Run or walk? Or just lay low? Massively confused.</p>
<p>Observation: He doesn’t know which events to pay attention to. He keeps looking around.</p>
<p>Hypothesis: Doesn’t know which inputs are relevant for the techniques he has.</p>
<p>For example, he can’t do anything about the aircrafts exploding miles away. So, ignore them. Ditto for the people already dead - no technique will bring them back. So, ignore them too. His gun can shoot only things that are nearby - so, focus only on targets that are nearby.</p>
<p>Observation: Guy spasming in his exo-suit. Cage gawks.</p>
<p>Observation: Hmm… A big part of being confused seems to be about wasting time on useless parts of the input.</p>
<p>Hypothesis: Given the techniques you have, you need to ignore all the parts of the inputs that are irrelevant. Otherwise, you will be overwhelmed because you have nothing stored in your mind for that exact “complex” configuration.</p>
<p>For example, Cage (along with us as the viewers) is overwhelmed by the fact that there are dozens of aircrafts hovering above doing crazy shit, missiles flying everywhere, and so on. We have no clear rule for what to do in this situation. But once you realize that all you can do with your weapons is shoot things that are nearby, you will ignore all of these factors and focus on any mimics who are close. You know how to respond to <em>that</em> situation: see mimic, shoot it.</p>
<p><strong>Hypothesis</strong>: If you have a bunch of clear high-level techniques but you focus on too many irrelevant variables, you will feel like you don’t know which technique you need for that configuration. You will be “confused”.</p>
<p>Lesson: Ignore irrelevant variables. Basically don’t waste time on useless things, like Cage gawking at the spasming soldier. Take your mind off those things.</p>
<p><strong>Lesson</strong>: Don’t pay attention to anything that is irrelevant to your target and weapons.</p>
<p>For example, don’t pay attention to the missile that just took out the guy next to you (apart from remembering to duck and walk in zigzag patterns or whatever). Don’t pay attention to the guy on fire - can’t do anything about it; will only confuse you. Don’t pay attention to the aircraft on fire (past ensuring that it’s not going to fall on you).</p>
<p>Observation: Gun - some error message in Japanese - don’t know what to do for this configuration (in order to get his safety off).</p>
<p>Hypothesis: What options does he have? He could press some combination of the buttons on the gun. One of them must turn the safety off. It is probably not some “complex” procedure because people have to do it quite often. Focusing on the fact that it is in Japanese and that you don’t know the language and that you’re screwed and so on is unhelpful.</p>
<p>Observation: Crashing aircraft. He came up with the correct response - running and jumping into a ditch.</p>
<p><strong>Observation</strong>: Swordsmen are famous for having their attention completely on their opponent. They don’t waste attention on worrying about what others think of them (because their weapon can’t help them do anything about that).</p>
<p>Observation: The only weapon he had left was the explosive. What is the only thing he could do with it? Detonate it when the enemy got close. He did that. Every other detail was irrelevant.</p>
<p>Observation: He wakes up after dying. Confused. Doesn’t know what to do for such an input configuration. What can he do? Live life again, become stronger, and hopefully kill some more mimics. The rest is kind of irrelevant. (Though he should figure out how he was awoken.)</p>
<p>Observation: Rita dies after killing the first mimic; the second time around, he’s coming up with a better technique for the same situation. (The theme of the whole movie.)</p>
<p>Question: Given a particular situation and target, how do you improve your technique?</p>
<p>Hypothesis: Use the scientific method with the input as the situation plus your technique, and the output as the outcome of your actions.</p>
<p>Notice how different variations of your technique lead to different outcomes and infer a model of which technique configurations lead to good outputs.</p>
<p><strong>Hypothesis</strong>: Basically, use the outputs to categorize your technique configurations.</p>
<p>For example, if trying to convince the Sergeant gets you nowhere, stop doing that. Eliminate that variable from your technique configuration space.</p>
<p>Hypothesis: For each input configuration, choose the high-level technique that gets you the best outcome. Categorize inputs this way.</p>
<p>Observation: He jumped off right away. He knew that other techniques would get bad results. Landed on his feet too. He’s running with a purpose now. He knows what to do for the current input.</p>
<p>Observation: Got hit by the jeep once. Not again.</p>
<h2 id="relevant-variables-only-but-still-confused">Relevant Variables Only but Still Confused?</h2>
<p>For example, I didn’t know whether to use <code>G_-X_Z-</code> or <code>G_X-_Z-</code> for rule 2 of do-calculus.</p>
<p>Hypothesis: I knew that I needed to use rule 2 in that situation, but I was confused about the <em>definition</em>.</p>
<p>Hypothesis: This is just confusion at one level down. For the input “use rule 2”, I didn’t know the correct output.</p>
<p>Instead of being confused about the high-level technique to use, I was confused about a lower-level technique within it.</p>
<h2 id="what-if-you-have-a-lot-of-low-level-techniques">What if You have a Lot of Low-level Techniques?</h2>
<p>For example, the gun had some error message in Japanese. How could Cage go about testing the different combinations of buttons on the gun to turn the safety off?</p>
<h2 id="what-if-you-have-no-techniques">What if You Have No Techniques?</h2>
<p>Question: What if you don’t have any high-level techniques?</p>
<p>For example, if you asked me to fix a broken car engine, I would have no clue what to do. There too, I would be “confused”.</p>
<h2 id="im-confused-vs-im-confused-about-x">“I’m confused” vs “I’m confused about X”</h2>
<p>Test: EB - told him I was confused about the linear programming part of ACE. He refused to back down until I specified exactly <strong>which line</strong> I didn’t understand. And when he did write it out, it was obvious!</p>
<h1 id="novice-go-slow">Novice: Go Slow</h1>
<p>Observation: Felt a lot more in control when I applied each do-calculus rule deliberately. Basically wrote out the entire condition for the rule so that I wasn’t caught by edge cases.</p>
<h1 id="unit-tests-are-better-than-blind-integration-tests">Unit Tests are better than Blind Integration Tests</h1>
<p>Observation: For HW2 in SML, I went with a benchmark of tests, where I understood neither the input nor the output data.</p>
<p>Observation: I can understand a single concrete test better.</p>
<p><strong>Hypothesis</strong>: Go for well-understood simple unit tests over blind integration tests -&gt; actually feel confident about your code vs don’t know why it works or even what it’s supposed to do.</p>
<h1 id="classified-information-everything-should-flow">Classified Information: Everything Should Flow</h1>
<p>Hypothesis: Aim of information-storage: Collect all your data into the same flow. A model must either be an alternative to or an extension of another model.</p>
<p>Corollary: You shouldn’t have information that’s just lying around. It should fit within your overall model.</p>
<h2 id="detect-redundant-models-using-concrete-examples">Detect Redundant Models using Concrete Examples</h2>
<p>We don’t want to store more than one hypothesis for the same problem type. Then, we would get confused about which one to use. Hypotheses must either be alternatives to each other (with well-defined unique inputs) or extensions (where you use one after the other).</p>
<p>Question: How to detect whether you already have a hypothesis for a given problem?</p>
<p><strong>Hypothesis</strong>: Use a concrete example vs use some name for the model -&gt; recall your existing model for that example vs may not remember existing models you have for the same problem.</p>
<p>For example, “confusion” and “being overwhelmed” and “seems chaotic” and so on refer to the same problem - not knowing which output to produce for a given input. Things become clearer when I give the example of a battle field (like in Edge of Tomorrow). All the above labels would apply, which makes me understand that I have more than one model for the same situation and I must mark them as equivalent (at least for this problem).</p>
<p>Corollary: Using lower-level concepts will do just as well.</p>
<p>For example, “boundaries” and “personal space” and “personal rights” all boil down to the economic concept of “property rights” - stuff that you control.</p>
<h1 id="static-types-help-you-abstract">Static Types help you Abstract</h1>
<p>Observation: Writing a Python function to flatten a YAML dictionary that had two redundant nested lists of dictionaries. Was going to write some hopelessly ad hoc function to deal with “innings” and “deliveries” (since those were the keys that had the nested lists).</p>
<p>Then realized that I should just write one generic function to flatten a list of dictionaries, and use that on innings and deliveries separately.</p>
<p>Would have been a no-brainer in Haskell. The type would have made it obvious (I think).</p>
<p>Hypothesis: Static types (a la Haskell) help you abstract, whereas dynamic types make it hard to see the patterns.</p>
<p>(Feels overly-general.)</p>
<h1 id="pass-a-test-with-a-chain-of-function-calls">Pass a Test with a Chain of Function Calls</h1>
<p><strong>Inference</strong>: A test will run only one branch. So, no if-statements needed. Probably just a chain of function calls.</p>
<p><strong>Hypothesis</strong>: To pass a well-designed test, you will need only a chain of function calls.</p>
<h2 id="one-test-per-function-in-the-chain">One Test per Function in the Chain?</h2>
<p><strong>Question</strong>: How many tests for a function with no if-statements but a chain of function calls?</p>
<p><strong>Hypothesis</strong>: When you have a chain f . g . h, you will need to show why you need each individual function (and if possible, each combination).</p>
<p>Test: In <code>website-join-disjointed-paragraphs</code>, I have</p>
<pre class="elisp"><code>(my-map-paragraphs-in-buffer
   (-compose (-partial 's-join &quot; &quot;)
	     (-partial '-filter 's-present?)
	     's-lines))</code></pre>
<p>I was puzzled. Why do I need that function in the middle: <code>(-partial '-filter 's-present?)</code>? I can see that <code>s-lines</code> turns a string with disjointed lines into a list of lines and that <code>s-join</code> joins them into one paragraph. When will you possibly need to filter with <code>s-present?</code>?</p>
<p>I looked at my unit test for that function (I had just one) and couldn’t see why you needed that <code>s-present?</code> function. In fact, that test passed even without the middle function. However, another test, one that tested this function on a real-world input failed. Only then did I realize that that function was there to handle a trailing newline, which all my files have.</p>
<p>I tested that theory by adding a smaller, specific test with a trailing newline and saw that toggling <code>s-present?</code> made that test pass or fail.</p>
<p>Basically, I needed to show that my function definition needed that middle function in order to pass some test.</p>
<h2 id="compose-properties-of-functions">Compose Properties of Functions</h2>
<p>It feels like that when we compose functions, we compose their properties to get the overall property.</p>
<p>Test:</p>
<pre class="elisp"><code>(defun s-join-broken-paragraph (s)
  &quot;Join broken lines in paragraph string S.&quot;
  (funcall (-compose (-partial 's-join &quot; &quot;)
	     (-partial '-filter 's-present?)
	     's-lines)
	   s))</code></pre>
<p>We know that <code>s-lines</code> will break a string into lines, <code>filter s-present?</code> will keep only those lines that are not empty, and that <code>s-join &quot; &quot;</code> will join those lines with a space in between. So, does that sum up to “join broken lines in paragraph string”?</p>
<p>Note that a big assumption is that there is only one paragraph with broken lines. If the input looks like:</p>
<pre><code>This is
the first
paragraph. Phew.

This is actually the second
paragraph. Uh oh.</code></pre>
<p>the output is:</p>
<pre><code>This is the first paragraph. Phew. This is actually the second paragraph. Uh oh.</code></pre>
<p>which is not what I want.</p>
<p>Observation: I’m assuming that a “paragraph” is some “complex” thing with lots of possible cases that I will have to handle.</p>
<p>But if we assume that one broken paragraph is just a bunch of lines with none of them separated by a blank line, then our job becomes a lot easier.</p>
<p>If we assume that a broken paragraph is a bunch of lines, then s-lines will get us all of those lines. Right now, the <code>filter s-present?</code> is just there to handle a trailing newline, so let’s ignore it. The <code>s-join &quot; &quot;</code> takes the lines and creates a string out of them.</p>
<p><strong>Hypothesis</strong>: To handle all possible configurations of some variable:</p>
<p>unpack it, do something to each part, combine them -&gt; “handle” that variable.</p>
<h2 id="succinct-properties">Succinct Properties?</h2>
<p>Test:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> <span class="kw">let</span> d <span class="fu">=</span> fromList <span class="fu">$</span> zip [<span class="dv">1</span><span class="fu">..</span>] [<span class="ch">'a'</span><span class="fu">..</span><span class="ch">'z'</span>]
fromList [(<span class="dv">1</span>,<span class="ch">'a'</span>),(<span class="dv">2</span>,<span class="ch">'b'</span>),(<span class="dv">3</span>,<span class="ch">'c'</span>),(<span class="dv">4</span>,<span class="ch">'d'</span>),(<span class="dv">5</span>,<span class="ch">'e'</span>),(<span class="dv">6</span>,<span class="ch">'f'</span>),(<span class="dv">7</span>,<span class="ch">'g'</span>),(<span class="dv">8</span>,<span class="ch">'h'</span>),(<span class="dv">9</span>,<span class="ch">'i'</span>),(<span class="dv">10</span>,<span class="ch">'j'</span>),(<span class="dv">11</span>,<span class="ch">'k'</span>),(<span class="dv">12</span>,<span class="ch">'l'</span>),(<span class="dv">13</span>,<span class="ch">'m'</span>),(<span class="dv">14</span>,<span class="ch">'n'</span>),(<span class="dv">15</span>,<span class="ch">'o'</span>),(<span class="dv">16</span>,<span class="ch">'p'</span>),(<span class="dv">17</span>,<span class="ch">'q'</span>),(<span class="dv">18</span>,<span class="ch">'r'</span>),(<span class="dv">19</span>,<span class="ch">'s'</span>),(<span class="dv">20</span>,<span class="ch">'t'</span>),(<span class="dv">21</span>,<span class="ch">'u'</span>),(<span class="dv">22</span>,<span class="ch">'v'</span>),(<span class="dv">23</span>,<span class="ch">'w'</span>),(<span class="dv">24</span>,<span class="ch">'x'</span>),(<span class="dv">25</span>,<span class="ch">'y'</span>),(<span class="dv">26</span>,<span class="ch">'z'</span>)]
<span class="dt">Prelude</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> fromList <span class="fu">.</span> map Data.Tuple.swap <span class="fu">.</span> toList <span class="fu">$</span> d
fromList [(<span class="ch">'a'</span>,<span class="dv">1</span>),(<span class="ch">'b'</span>,<span class="dv">2</span>),(<span class="ch">'c'</span>,<span class="dv">3</span>),(<span class="ch">'d'</span>,<span class="dv">4</span>),(<span class="ch">'e'</span>,<span class="dv">5</span>),(<span class="ch">'f'</span>,<span class="dv">6</span>),(<span class="ch">'g'</span>,<span class="dv">7</span>),(<span class="ch">'h'</span>,<span class="dv">8</span>),(<span class="ch">'i'</span>,<span class="dv">9</span>),(<span class="ch">'j'</span>,<span class="dv">10</span>),(<span class="ch">'k'</span>,<span class="dv">11</span>),(<span class="ch">'l'</span>,<span class="dv">12</span>),(<span class="ch">'m'</span>,<span class="dv">13</span>),(<span class="ch">'n'</span>,<span class="dv">14</span>),(<span class="ch">'o'</span>,<span class="dv">15</span>),(<span class="ch">'p'</span>,<span class="dv">16</span>),(<span class="ch">'q'</span>,<span class="dv">17</span>),(<span class="ch">'r'</span>,<span class="dv">18</span>),(<span class="ch">'s'</span>,<span class="dv">19</span>),(<span class="ch">'t'</span>,<span class="dv">20</span>),(<span class="ch">'u'</span>,<span class="dv">21</span>),(<span class="ch">'v'</span>,<span class="dv">22</span>),(<span class="ch">'w'</span>,<span class="dv">23</span>),(<span class="ch">'x'</span>,<span class="dv">24</span>),(<span class="ch">'y'</span>,<span class="dv">25</span>),(<span class="ch">'z'</span>,<span class="dv">26</span>)]</code></pre></div>
<p>We can see that <code>toList</code> will get us a list of all the key-value pairs, <code>map swap</code> will make them value-key pairs, and <code>fromList</code> will construct a new map from them.</p>
<p>Of course, one edge case is when there is more than one key with the same value. Which one will be lost? The one that comes earlier in the key ordering.</p>
<p>These two function chains were easy enough. When might function chains be hard to reason about?</p>
<p>You could have a really long function chain or you could have lots of possible variations.</p>
<p>For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> <span class="kw">let</span> xs <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
<span class="dt">Prelude</span> <span class="dt">Data.List</span><span class="fu">&gt;</span> take <span class="dv">3</span> <span class="fu">.</span> reverse <span class="fu">.</span> sort <span class="fu">.</span> nub <span class="fu">.</span> take <span class="dv">20</span> <span class="fu">.</span> sort <span class="fu">.</span> take <span class="dv">30</span> <span class="fu">.</span> cycle <span class="fu">$</span> xs
[<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>]</code></pre></div>
<p>Why is the output [7, 6, 5]? I don’t really know. But I can sort of follow the chain.</p>
<p>Aren’t there all kinds of possible configurations? I don’t think so. It’s a list, so there are two cases - the empty list and the non-empty list. If xs is empty, the output at every point along the chain will be empty. So, that’s a trivial case.</p>
<p>Now, you just have to take a non-empty list. Shouldn’t you have to consider a lot of possible lists, maybe those that have just one element or five elements?</p>
<p>Observation: You can’t make any sort of closed-function claim about the output list. You will say that it will have the output that is dictated by the chain.</p>
<p>Observation: In the key-value swapping example before, I could claim succinctly that the final map would have key-value pairs but in the opposite order.</p>
<p><strong>Hypothesis</strong>: Some function chains lend themselves to succinct properties, some don’t. (How falsifiable!)</p>
<p>Observation: The long chain above, if encapsulated as a function, would have a very large <em>interface</em>. You couldn’t do better than just describing the chain itself.</p>
<p>Observation: When you <code>mappend</code> two strings, what you get back is still a string.</p>
<p>Question: Out of all the possible implementations of Monoid or Functor or Monad, why do we choose particular ones?</p>
<p>Test: What does it mean when you compose two Parsers? What properties are you composing?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">abParser ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)
abParser <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="fu">&lt;*&gt;</span> char <span class="ch">'b'</span></code></pre></div>
<h2 id="properties-of-intermediate-values">Properties of Intermediate Values</h2>
<p>Test: Poorly-written abstract function that I found hard to understand (part of a Sudoku solver I wrote):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">boxes3x3' ::</span> <span class="dt">Eq</span> b <span class="ot">=&gt;</span> <span class="dt">Matrix</span> b <span class="ot">-&gt;</span> <span class="dt">Matrix</span> [b]
boxes3x3' <span class="fu">=</span> fmap concat <span class="fu">.</span> overMatrix (concatMap (replicate <span class="dv">3</span> <span class="fu">.</span> concatMap (replicate <span class="dv">3</span>)) <span class="fu">.</span> map ( transpose <span class="fu">.</span> map byThrees) <span class="fu">.</span> byThrees)</code></pre></div>
<p>What now?</p>
<p>Note, however, that the interface of the function is actually pretty simple. It needs to take a Sudoku matrix where each cell contains a list of its possible values and return a matrix where each cell contains the possibilities for all the cells in its 3x3 box. (A test case would have helped greatly.)</p>
<p>Hypothesis: You need to understand the properties of the data structure at each point in the function chain.</p>
<p>Ok. I understood the function. <code>overMatrix</code> lets you map over the rows in the Matrix. <code>byThrees</code> gets you three rows at a time. Then, consider <code>transpose . map byThrees</code> on the first three rows. <code>map byThrees</code> gets you the three column values at a time for each row. <code>transpose</code> on that for the first three rows gives you the first three 3x3 boxes in the Sudoku matrix. Basically, at this point, you’ve got a 3x3 matrix of boxes. You want to give the same box to all the 9 cells in each box, so <code>concatMap (replicate 3 . concatMap (replicate 3))</code> turns the 3x3 matrix of boxes into a 9x9 matrix of boxes, where each cell has the 3x3 box that it resides in. <code>fmap concat</code> flattens each 3x3 box to give a 9-element list of its elements.</p>
<p>Observation: We can break this into three parts: the first part where you get a 3x3 matrix of boxes, the second part where you get a 9x9 matrix of boxes, and the final part where you get a 9x9 matrix of lists.</p>
<p><strong>Hypothesis</strong>: Chain - get the data type at each point and ask for its properties with respect to your goal.</p>
<p>Question: How many tests would you need to be confident in your implementation of each part? How do you know that your code really will get a 3x3 matrix of the 9 boxes in the Sudoku matrix?</p>
<p>Well, the input numbers don’t really matter. So, that reduces a lot of possible input configurations.</p>
<p><strong>Question</strong>: For any given input matrix, should we test for the entire output or can we just test a few cells?</p>
<h2 id="verify-properties-using-quickcheck">Verify Properties using QuickCheck</h2>
<p><strong>Hypothesis</strong>: Function - verify its properties using QuickCheck.</p>
<p>Test: boxes3x3’ must return a 3x3 matrix of boxes corresponding to the input Sudoku matrix – we can use QuickCheck to verify that.</p>
<h2 id="how-many-tests-for-a-chain-of-functions">How Many Tests for a Chain of Functions?</h2>
<p><strong>Question</strong>: How many tests do I need to for a chain of functions?</p>
<p>Just one? No matter what the functions are? Seriously?</p>
<p>Hypothesis: I want to know the causes of #tests for chain of functions. What are the variables? Number of functions in the chain, whether it’s about the limits of my mind vs the actual uncertainty I have about the code, the number of branches of each function, and the size of their interfaces.</p>
<h1 id="searching-within-the-program-space">Searching within the Program Space</h1>
<h2 id="code-transformation-fail-to-fail-gives-no-information">Code Transformation: Fail to Fail gives No Information</h2>
<p><strong>Hypothesis</strong>: Going from fail to fail doesn’t give you any information about your latest change.</p>
<p>old code -&gt; fail (so we know it’s broken)</p>
<p>old code broken + correct change -&gt; fail old code broken + wrong change -&gt; fail</p>
<p>Going from fail to pass tells you that your latest change is correct.</p>
<p>Going from pass to pass tells you that your latest change is correct. This is true if you changed the code, but not necessarily if you added new code (you may have forgotten to test it).</p>
<p>Going from pass to fail tells you that your latest change is wrong.</p>
<h2 id="why-is-writing-abstract-code-time-consuming">Why is writing Abstract Code time-consuming?</h2>
<p>Question: What is the exact difference in coding time between passing the test and then refactoring vs passing the test with clean code?</p>
<p><strong>Hypothesis</strong>: Pass the test with ugly code -&gt; 1 test (though you may sometimes test different parts of the chain too). Refactor the ugly code that <em>works</em> -&gt; m tests (one for each abstraction like function or class).</p>
<p>You would go from no code to code that works. 1 test. Then, you would go from code that works to code that works plus one abstraction. Then, you would go again from code that works to code that works plus abstraction. And so on till you’re satisfied. m tests.</p>
<p>Pass the test with clean code -&gt; suppose you add m abstractions and the test fails. You will need to toggle many of those abstractions (which will take time) before you isolate the bug.</p>
<p>You would go from no code to code that doesn’t work plus abstraction. Then, from code that doesn’t work to code that doesn’t plus abstraction. And so on.</p>
<p>Even if you ran a test at each point, you wouldn’t know if it doesn’t work because the current abstraction is broken or because the prior abstractions are.</p>
<p>Corollary: This whole problem would be solved if you could add abstractions like you add code. Then, you could unit test each change and romp ahead.</p>
<h2 id="why-is-debugging-so-hard">Why is Debugging so Hard?</h2>
<p>Observation: Debugging seems to be pretty hard and time-consuming. Lot more confusing and frustrating than normal coding.</p>
<p>For example, 17 out of the 30 hours I spent on OS HW2 were lost in debugging.</p>
<p>Why? Is debugging a different operation from normal coding?</p>
<h2 id="a-model-of-programming">A Model of Programming</h2>
<p>Observation: Consider a case where you have a multi-variable configuration space like (A2, B5, C1) -&gt; pass; (A1, B8, C5) -&gt; fail; etc. We will call each configuration a “program”.</p>
<p>You have different “features” that will let you change the program from one configuration to another. For example, “sort the output list” could correspond to going from B5 to B6 and thus take your program (A2, B5, C1) to (A2, B6, C1).</p>
<p>However, you are not a perfect programmer, so you could make a mistake while implementing the first feature and end up at some other value than B6.</p>
<p>Basically, you can’t tell if you are at B6. You have to infer from the result of your test case that checks for a sorted output list. It will go from “fail” for B5 to “pass” for B6 and thus tell you that you implemented the feature correctly.</p>
<p>Let’s say C1 is a function to compute the mean-squared error for two vectors. It does all that in one function. C3 is a function that does the same thing but has a “cleaner design” than C1: it calculates the error vector first and then calls <code>meansqr</code> for it. So, it requires two additional features on top of C1 - separate functions for <code>error</code> and <code>meansqr</code>. So, you have to go from C1 to C2 (i.e., C1 + <code>error</code>) and then from C2 to C3 (C1 + <code>error</code> + <code>meansqr</code>).</p>
<p>Now, the clean way to get to C3 would be to extract <code>error</code> in C1 and run a test to see if you really are at C2 (which would be the same test for C1 because C1 and C2 behave identically). Then, extract <code>meansqr</code> and run a test to see if you really are at C3 (which is the same test as for C1 or C2 as they all behave identically). Even if you made a mistake while extracting <code>error</code>, you would know that the error (heh) would be in your latest change, not anywhere else in the code. Simple. No frustration.</p>
<p>What if you extracted <code>error</code> and <code>meansqr</code> in one shot? Well, if your implementation of C3 passed the test, then you could be pretty confident that you did it right.</p>
<p>But what if the test for C3 fails? Now, you don’t know if the problem is in your extraction of <code>error</code> or in your extraction of <code>meansqr</code>.</p>
<p>How would you handle this? The best way would be to go back to the inline version of <code>meansqr</code> and check if the test passed then. If so, the problem is in your extraction of <code>meansqr</code> and you can run finer tests.</p>
<p>Assume that you didn’t have to write new code manually or press undo in your editor repeatedly till you got back to C2 and ran your test. What if you could jump from C1 to C2 or from C2 to C1 in a flash? Basically, what if you could toggle any implemented feature instantaneously?</p>
<p>Well, if your original code passed the test for C1 but your implementation of features <code>error</code> and <code>meansqr</code> failed the test, you could tell that the problem must have been somewhere in the implementation of the two features. Then, you could just toggle <code>meansqr</code> and see if that code passed the test. Say it doesn’t. So, there must be a problem with <code>error</code> (there may also be a problem with <code>meansqr</code>; we don’t know). We then toggle features within <code>error</code> to check which one broke our code until we pinpoint the culprit.</p>
<p>In the worst case, you need two tests - one to check <code>error</code> and one to check <code>meansqr</code>, which is the same number of tests as in normal coding where you test after every feature.</p>
<h2 id="debugging-is-hard-when-you-cant-toggle-easily">Debugging is Hard when you Can’t Toggle Easily</h2>
<p>Observation: Some state transitions are costlier in the reverse direction.</p>
<p><strong>Hypothesis</strong>: Debugging is hard when you can’t toggle the state space easily.</p>
<p>You can figure out the right configuration effortlessly if you can walk through state configurations in an instant. (In fact, you can even automate it.)</p>
<h2 id="hard-to-toggle-abstractions">Hard to Toggle Abstractions</h2>
<p><strong>Hypothesis</strong>: It’s easy to toggle tests.</p>
<p>I did it effortlessly with my <code>pipe</code> tests.</p>
<p><strong>Hypothesis</strong>: It’s hard to toggle abstractions.</p>
<p>Except for the last few edits or so, our editors don’t allow us to roll back abstractions. It’s a pain even if you use git.</p>
<p><strong>Hypothesis</strong>: Abstractions are usually set in stone.</p>
<p>Once you add an abstraction (like a class or function), it’s so hard to get back the original code that you stick with the abstraction.</p>
<p>But you don’t know if your abstraction itself was correct. So, you’re now uncertain about both your abstraction and your code’s behaviour.</p>
<p><strong>Hypothesis</strong>: Hard to decide whether or not to go for an abstraction unless you know the potential use cases.</p>
<p><strong>Corollary</strong>: You will dilly-dally. You won’t spend your time coding; you will spend it pondering.</p>
<h2 id="one-thing-at-a-time-abstract-while-coding---more-uncertain">One Thing at a Time: Abstract while Coding -&gt; More Uncertain</h2>
<p>For example, when testing a class in Python, I wrote the code to generate test data in the <code>setUp</code> method. But that meant that code was regenerated for test case, which was wasteful. So, I decided to move it to the class constructor. But that failed because the TestCase constructor expected two inputs (I think. I’m not sure. That’s the point). Which ones? I don’t know. So, I looked online for more details. People recommended that I use a <code>setUpClass</code> method. But that was a “class method”. I wasn’t sure what that was - a static method like in Java or something else. Anyway, I tried using <code>self.foo</code> everywhere and the code failed. Why? Because <code>self</code> wasn’t even visible in the class method (obviously). So, I replaced every instance of <code>self</code> with <code>cls</code> (since that was the name of the argument). Then my code worked.</p>
<p><strong>Hypothesis</strong>: We are more uncertain about abstractions than about normal code.</p>
<p>Corollary: So we are likely to make more mistakes when abstracting than when writing usual functions. That explains my struggle above.</p>
<p>Observation: When calculating the total runs for a player in the first and second innings, I wanted to abstract the loop into a function and call that function on the two parts. Instead, I forced myself to write two duplicate loops (<em>cringe</em>). But the code still failed the test. So, if I had abstracted the loop into a function, I would have been unsure if the problem was because of my abstraction or because of the code itself.</p>
<p><strong>Observation</strong>: Holy crap. Refactoring was a breeze! I could see exactly what I needed to change (extract a Match::balls iterator) and did it without any worries about the behaviour.</p>
<p>Observation: Again, when trying to aggregate stats from 70 matches, I’m trying to look for the ideal solution where I pickle the YAML object for future use and so on. Instead, I should just run it in a quick and dirty way, no matter what the cost.</p>
<p>Observation: Lost my way after a while and reverted to my old over-engineering habits.</p>
<h2 id="default-values-for-abstractions">Default Values for Abstractions</h2>
<p><strong>Hypothesis</strong>: Have default values for abstractions -&gt; can add an abstraction without making mistakes and without changing behaviour vs have to add an abstraction (perhaps making mistakes) and change behaviour too.</p>
<p>Observation: Still hard to reverse an abstraction.</p>
<h2 id="moving-forward-is-easier-than-debugging-backward">Moving Forward is easier than Debugging Backward</h2>
<p><strong>Lesson</strong>: Adding features and releasing at each point -&gt; quick and painless. Adding lots of features and then debugging -&gt; slow and painful (because you can’t toggle features easily).</p>
<h1 id="premature-abstraction-considered-harmful">Premature Abstraction Considered Harmful</h1>
<p>Observation: I’m struggling to get actual stats from the IPL match data even though it’s a pretty simple map of a simple function over each ball in the data.</p>
<p>Observation: I’m trying to get a “good” (aka perfect) design of Match and Ball and Player and PlayerStats. Even though all I really want is the average and total runs for each player.</p>
<p>Observation: Quick and dirty way of doing it - total runs = map over deliveries in both innings and if batsman is the given batsman, add runs scored by batsman.</p>
<p>Observation: How <em>I</em> want to do it - <code>match.get_player_stats()</code> with different seasons and so on.</p>
<p>Hypothesis: Focus on passing the test in an ugly way, then refactor -&gt; fast code + clean; focus on writing clean code -&gt; may waste time worrying about “good” design.</p>
<p>Hypothesis: Focus on passing the test in an ugly way -&gt; have code that actually <em>works</em> for some input, goddamit. Focus on writing clean code -&gt; may have code that doesn’t work for any useful input yet even after an hour of thinking.</p>
<p>Why would it be a net win to write ugly code and then refactor, rather than write clean code the first time around?</p>
<p>Hypothesis: Code that works, refactor it -&gt; you’re changing only one thing at a time (design, not behaviour) -&gt; very little time, can choose how clean you want your design to be wrt expected inputs.</p>
<p>Code that doesn’t work, write clean code -&gt; you’re changing two things at the same time (design <em>and</em> behaviour) -&gt; will take longer (?), may overengineer.</p>
<p>Observation: You don’t want to write lots of code without stopping to test. You will get very confused if you get an error. (?)</p>
<p>Hypothesis: Chain of functions that we understand -&gt; won’t take much time (why?). Branches of functions -&gt; will take time (why?).</p>
<p>Corollary: So, writing “ugly”, concrete code to pass a unit test won’t take too much time.</p>
<p>Observation: What about abstract code that still just passes one test case? For example, <code>Match:get_balls()</code> and <code>Match:map_over_balls()</code> and <code>runs_for_ball()</code>.</p>
<p>Observation: The abstraction <code>Match:get_balls()</code> may or may not work. You may have made a mistake in defining the method or in the module scope (if Match is in another file) or whatever. Source of uncertainty - have to test it.</p>
<p>Observation: You have multiple design choices - different levels of abstraction. For example, you could deal with separate methods for <code>get_balls()</code> and <code>map_over_balls()</code>, but not a separate class for <code>PlayerStats</code>. Or you could go the whole way and have subclasses for BowlerStats and BatsmanStats (and of course FielderStats) and have, god forbid, visitor methods to do complicated processing. But, for my problem of extracting data for machine learning, that is simply overkill.</p>
<p>Observation: Each time you add a new abstraction, you have to test it (since you may or may not have implemented the abstraction correctly, or may have even picked one that doesn’t fit your problem).</p>
<h2 id="rule-of-three">Rule of Three</h2>
<p><strong>Question</strong>: What if you abstracted code only on the second use?</p>
<p>Maybe go for the Rule of Three? (https://blog.codinghorror.com/rule-of-three/)</p>
<p>What’s the worst that can happen if you <em>don’t</em> abstract your code?</p>
<p><strong>Inference</strong>: Unabstracted code is hard to understand and hard to change too. It’s not just about reuse.</p>
<p>I don’t know the answer.</p>
<h2 id="quick-and-dirty-vs-clean-why-i-procrastinate">Quick-and-Dirty vs Clean: Why I Procrastinate</h2>
<p>Observation: I had the idea that mock objects were actually unnecessary if you strictly separated pure code from impure code, like in Haskell or other languages. That’s why you didn’t see Haskellers go ga-ga over mocks. (In fact, you don’t see anybody except Agile fellows.)</p>
<p>But then I got caught up in writing some elisp code (which took over two hours). Then I felt like searching online for some precision teaching books. And finally I was late for a video call. So I didn’t write down my full ideas about mock objects and didn’t commit that code. And it weighed on my mind even as I was freshening up.</p>
<p>Question: Why didn’t I simply jot down the rough idea as I did above? It would have taken me a couple of minutes, tops. It may not have been perfect, but I could commit the change and free my mind.</p>
<p><strong>Hypothesis</strong>: Expect to write correct abstract code before I commit, have some idea I need to write down, little time -&gt; don’t write it down at all.</p>
<p>Expect to just pass the test with a quick and dirty hypothesis (and maybe refactor later), have some idea, little time -&gt; write it down well enough to pass that specific test.</p>
<p>Corollary: Expect to have code that passes all tests written down (and put only as much confidence in your hypothesis as the tests warrant) -&gt; can do what needs to be done faster.</p>
<p>Test: Jotting down my mock objects idea – I wanted to get a general hypothesis that fit with all my other “complex” programming ideas.</p>
<h1 id="write-and-test-in-isolation-before-you-use">Write and Test in Isolation before You Use</h1>
<p>When you want to extend a function with some new function, test your new code as a function before you use it here. For example, if you want your <code>generate_stats</code> function to write the final matrix to a file (why do you want to do that within the same function?), have a separate function that writes a matrix to a file, test it, and then use it here.</p>
<p>Observation: I ended up with a script that was costly to test when I was extracting ftrs from a dataset. I/O was mixed with program logic.</p>
<p>Corollary: You will end up with one-button changes to your original function, so it will be easier to test too (as compared to the case where you simply dumped code at the end of the function).</p>
<h1 id="deliberate-execution-of-hypothesis">Deliberate Execution of Hypothesis</h1>
<p>Test your explicit hypothesis at each step by asking it what to do. If it’s blank, fill it in with your intuitive next step. For example, use your “one-button change” hypothesis to write your course programs.</p>
<p><strong>Hypothesis</strong>: Live life “deliberately” -&gt; get an explicit hypothesis about a lot of things you do.</p>
<p>For example, should you watch a YouTube video now? What is the expected outcome? What else could you be doing? Read a book? Ok. Let’s say that’s what you need to do right now. Well, does it work to simply tell yourself “I need to read a book now”? Probably not. What does work? What passes the unit test “have read a book for an hour today”?</p>
<h1 id="type-signatures-the-technique">Type Signatures: The Technique</h1>
<p>Question: What problems can be solved only by thinking in terms of type signatures?</p>
<h1 id="refactoring-induction">Refactoring = Induction</h1>
<p>Observation: I got the right answers to the most questions in OS and SML. But I’m not confident about it. I felt like I just rote-learned most of the concepts the night before the exam.</p>
<p>Question: What’s the difference between rote-learning the night before the exam and proper learning over a period of time?</p>
<p>Question: What’s the difference between correct code that’s dirty and correct code that’s clean?</p>
<p>Observation: Refactoring gets you from dirty correct code to clean correct code. The final code is more general - easier to understand and change and reuse.</p>
<p>Hypothesis: The difference is induction.</p>
<p>Hypothesis: I’m confused about my course concepts and about dirty code because I haven’t got succinct general hypotheses from them. I’m still at the concrete level that’s hard to reason about because it’s verbose (and I don’t have a clear input-output relationship).</p>
<h2 id="how-much-work-is-refactoring">How Much Work is Refactoring?</h2>
<p><strong>Hypothesis</strong>: Two different concrete functions or hypotheses -&gt; one function that does both [call this refactoring or induction].</p>
<p>example: merge <code>get_strike_rates</code> and <code>get_averages</code> into a generic <code>get_features</code>.</p>
<p><strong>Question</strong>: How much work is it to refactor (inductively generalize) two functions (hypotheses)?</p>
<p>Hypothesis: First, check where they differ.</p>
<p>If they are nearly identical functions -&gt; just abstract the difference.</p>
<h2 id="tests-1">Tests</h2>
<p>Test: <code>get_strike_rates</code> and <code>get_averages</code> had the same code except for one function call. I could accept a function argument for that call alone.</p>
<h2 id="learning-and-induction">Learning and Induction</h2>
<p><strong>Question</strong>: Is this what I’m doing when I’m reading a new book that talks about a topic I’ve understood before? Am I trying to merge my current theory along with the new theory and evidence in the book to get a unified theory?</p>
<p>For example, if I read a book about the cognitive psychology of learning, I have to figure out how it fits with my existing model of associative memory and exponential decay. That feels like quite a bit of work.</p>
<h1 id="dont-change-a-function.-duplicate-it.">Don’t Change a Function. Duplicate it.</h1>
<p>Hypothesis: Want to change a <code>generate_stats</code> function to return the average instead of strike rate &lt;- make a duplicate function that’s specific for average. You can refactor it later.</p>
<p>Corollary: This way, you can switch between them easily.</p>
<p><strong>Hypothesis</strong>: Function &lt;- input and output types, output properties (i.e., the whole interface)</p>
<p>So, if you want to change the interface of the function (return averages instead of strike rates), even if the type is the same (list of numbers), write a separate function instead.</p>
<p><strong>Corollary</strong>: To avoid dead code, have an if-condition that lets you switch between the alternative functions.</p>
<h1 id="writing-tests">Writing Tests</h1>
<h2 id="granularity-of-tests">Granularity of Tests</h2>
<p><strong>Question</strong>: How do you chose the granularity of the function for which you want to write tests? (Excellent question.)</p>
<h1 id="refactor-before-you-commit">Refactor Before you Commit</h1>
<p>Observation: My <code>generate_stats</code> script is ugly and feels hard to refactor because it takes several minutes to run.</p>
<p>Observation: I didn’t refactor it the first time around when I was trying to just get the code to run. Yes, I want to pass the simple test as soon as possible, but I should refactor after that, so that my technical debt doesn’t pile up.</p>
<p>Hypothesis: Refactor before you commit -&gt; easier to code in the future.</p>
<p>Don’t refactor before you commit -&gt; end up with ugly code that’s hard to reason about.</p>
<h1 id="costly-feedback">Costly Feedback</h1>
<p>Question: How to write code when running tests is costly?</p>
<p>For example, it takes several minutes to test whether my <code>generate_stats</code> script gives the same output as before. So, I hesitate to refactor any part of it, lest I break the code in some way that will cost me a lot to fix (where I’ll have to run the script for several minutes again to make sure I really did fix it).</p>
<p><strong>Hypothesis</strong>: If you’re writing I/O code, separate the pure and impure parts. Now, you can quickly test and thus refactor the pure logic to your heart’s content.</p>
<h1 id="consider-all-possible-configurations">Consider All Possible Configurations</h1>
<p>Observation: Good security professionals seem to consider different possible scenarios.</p>
<p>Hypothesis: Think of contingency plans to most possible scenarios -&gt; high security vs poor security.</p>
<p>Observation: I haven’t considered different possibilities about my career plans. What if I hate my research area after a couple of years? What if I never make a breakthrough in “metacognitive algorithms”? No contingency plans.</p>
<h1 id="program-to-an-interface-not-an-implementation">Program to an Interface, not an Implementation</h1>
<h2 id="program-to-an-interface-hypothesis">Program to an Interface: Hypothesis</h2>
<p>Observation: When extending XINU in C, I wrote a few linked-list manipulation functions. They repeated several well-known functions like extract from linked list and so on. I shouldn’t have had to write them from scratch. But I couldn’t find any existing functions I could reuse (or rather, I didn’t look for them). Plus, it was a “unique” linked list structure - one where the elements were part of a pre-existing table, and were not dynamically generated. Still, there should have been a generic List interface that I could just use without knowing too much about the innards.</p>
<p><strong>Hypothesis</strong>: Program to an interface, not an implementation -&gt; code that is easier to understand, reuse, and modify.</p>
<p>For example, if you want to check if an element is a value in a Map, don’t search the specific functions within Data.Map. Look for the interfaces that it satisfies: Foldable, Traversable, Functor, Monoid, etc.</p>
<p>Test: You’re given <code>Maybe (Int, String)</code> and you want to map the string to its length (“foo” to 3). That is, you want to get <code>Maybe (Int, Int)</code>. <em>Don’t</em> try to unpack Maybe into the two cases Just and Nothing and then try to convert the inner values. Instead, realize that you want to deal with Maybe as a Functor. – easier to understand, easier to reuse (you could use it with any functor of functor), easier to modify (you could change the definition of Maybe).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dt">Just</span> (<span class="dv">3</span>, <span class="st">&quot;foobar&quot;</span>)
<span class="fu">*</span><span class="dt">Main</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> fmap (fmap length) x
<span class="dt">Just</span> (<span class="dv">3</span>,<span class="dv">6</span>)</code></pre></div>
<p>Compare that to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> <span class="kw">let</span> f (<span class="dt">Just</span> (x, s)) <span class="fu">=</span> <span class="dt">Just</span> (x, length s); f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Nothing</span>
<span class="fu">*</span><span class="dt">Main</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> f x
<span class="dt">Just</span> (<span class="dv">3</span>,<span class="dv">6</span>)</code></pre></div>
<p>This is a very specific function. You don’t know exactly what it’s doing unless you examine both the branches and realize that neither x nor the Maybe structure is affected, but the string s is turned into its length. It takes a while to realize that the whole point of the function was to turn the string into its length. With <code>fmap (fmap length)</code>, that purpose is front and centre. We know that we don’t care about the other value x or the structure of the Maybe value. Similarly, this is hard to reuse with any other type, such as a list of list of strings, because you have to handle a different type of structure, whereas the interface-version transfers easily:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span> <span class="dt">Data.Map</span><span class="fu">&gt;</span> fmap (fmap length) [[<span class="st">&quot;yo&quot;</span>, <span class="st">&quot;boyz&quot;</span>, <span class="st">&quot;I&quot;</span>], [<span class="st">&quot;am&quot;</span>, <span class="st">&quot;sing&quot;</span>, <span class="st">&quot;song&quot;</span>]]
[[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">4</span>]]</code></pre></div>
<p>Likewise, if you want to do something other than get the length of the string, you know exactly what to change - there are just three words in the function - “fmap”, “fmap”, and “length”. Whereas in the explicit version, you have to search for the precise thing you want to change and be wary of not affecting any of the surrounding code.</p>
<p>Test: You have a XML-like tree of sentences and you want to get all the verbs used in the tree. (Assume you have a function that will extract verbs from a sentence.) – treat the tree as Foldable and use <code>foldmap getVerbs</code>.</p>
<h2 id="minimize-the-number-of-your-weapons">Minimize the Number of your Weapons</h2>
<p>Observation: How do you check whether a value is in a Map? You could do (<code>elem</code> (elems m2)), but that would require you to know the function <code>elems</code>. Instead, you could just do (value <code>elem</code> m2)! Why? Because <code>Map</code> is in Foldable.</p>
<p><strong>Hypothesis</strong>: Have interface for commonly-used functions -&gt; don’t have to remember a lot of specific functions, can reuse code, can make your code more abstract.</p>
<p>Don’t have interface for commonly-used functions -&gt; have to remember specific functions, can’t reuse code, code is specific to that data type.</p>
<p>For example, I would have to know that <code>elems</code> was the function that returned all the values in a Map.</p>
<h2 id="mock-objects">Mock Objects</h2>
<p>Test: Test-Driven Development: A Practical Guide has a whole chapter about different types of “Mock” classes - Verifiable, MockObject, ReturnObjectList, Expectation, AbstractExpectation, ExpectationValue, ExpectationSegment, etc. Do we really need all those classes?</p>
<p>Observation: Haskell doesn’t seem to use these kinds of things. I don’t hear advanced programmers like PG or Stevey or others using mocks heavily.</p>
<p>Inference: Mocks -&gt; test behaviour of an interface without using costly I/O or computations.</p>
<blockquote>
<p>You may simply have a lot of fixture to put in place, or you may be working in the context of a large, complex system. This could be a database, a workflow system, or some system for which you are developing an extension (e.g., an IDE). Your fixture may involve getting the system into a specific state so that it responds the way your tests require. This may be impossible to do quickly.</p>
<p>– Test-Driven Development: A Practical Guide, Chapter 7</p>
</blockquote>
<p>Hypothesis: Separate pure code from impure code -&gt; won’t need to use mocks (much?).</p>
<p>What about my scheduler? Didn’t I need a default scheduler?</p>
<h1 id="refactoring-hypothesis">Refactoring Hypothesis</h1>
<h2 id="hypothesis">Hypothesis</h2>
<p>Starting out -&gt; get overall type signatures and goals.</p>
<p>one function definition - abstract it and run tests.</p>
<p>two function definitions with duplicated code and slightly different goals - extract common abstract functions and run tests.</p>
<p>one abstract function, old unrefactored code that you’re trying to subsume - check if it’s a subclass of your abstract function (that it handles a subset of the branches?)</p>
<p>prose - will talk about the causes of some key variable - collect them on that key variable.</p>
<p>two different sections talking about the same thing - collect the tests but ignore the hypotheses -&gt; get a combined hypothesis that passes all the tests, shrink your overall prose.</p>
<p><strong>Hypothesis</strong>: Lots of different sections talking about the corollaries of the same principle (like operant conditioning), organize them by interventions -&gt; maximum reusability, minimum code. Basically, do [situation, action -&gt; result].</p>
<p><strong>Question</strong>: What does this predict about programming to an interface? Will the code be easier to understand, reuse, and modify? Why?</p>
<h2 id="tests-2">Tests</h2>
<p>Test: <code>get_features_strike_rate</code> and <code>get_features_average</code> with <em>roughly the same code</em> except for <code>strike_rate</code> and <code>average</code> – accept a stat_fn and have a common abstract function.</p>
<p>Test: decisiveness - had three sections talking about it, collected them all under my newest explanation (indecisiveness is caused by optimizing for too many variables), was able to cover them all, shrank my prose. – I ignored the hypotheses and collected the tests.</p>
<p>Test: “Stuff not up to standards, insult -&gt; negative reinforcement for better action” – it’s in the form of [situation, action -&gt; result].</p>
<h2 id="refactor-this-essay">Refactor This Essay</h2>
<p>What are the tests I run to make sure the new version works the same as the old one?</p>
<p>Come up with an explicit hypothesis for the steps I need to follow while refactoring.</p>
<h2 id="key-variables">Key Variables</h2>
<p>process evidence vs get confused &lt;- how many high-level changes you make at a time (<strong>to what?</strong>)</p>
<p>change within existing function vs add a new function</p>
<p>easily toggled design variable vs not</p>
<p>how many changes you have to make to move from one design to another (one-button vs multiple changes)</p>
<p>have a default alternative stub that fails X’s unit test vs not (when you have just one value X and want to toggle it)</p>
<h1 id="hypotheses-about-hypotheses-model-of-the-domain">Hypotheses about Hypotheses: Model of the Domain</h1>
<p>Hypothesis: My state-transition <em>model</em> of programming seems to cover all the hypotheses that talk about amount of uncertainty about your program’s correctness or the amount of work required to fix bugs.</p>
<p><strong>Hypothesis</strong>: One type of hypothesis: move from concrete inputs to an abstract model, make abstract predictions, and then convert them to concrete predictions.</p>
<p>Test: Toggling one design variable at a time seems to be easier to handle than changing multiple variables – the state-transition model of programming seems to explain this.</p>
<p>Observation: My other “hypotheses” seem to be heavily under-specified. For example: [Multiple changes when trying to go to a desired state -&gt; could leave the system in a state that is “hard to reason about”]. The undefined terms here are “the system”, “state”, “multiple changes”, and “go to a desired state”.</p>
<p><strong>Question</strong>: How did you locate that abstract model in the first place? Aren’t you overgeneralizing from a few examples (a1 -&gt; b1 to a -&gt; b)?</p>
<p>Question: How do we write normal abstract programming functions?</p>
<p>Hypothesis: We categorize - we look at all the possible input configurations and group together those that give the same output configuration.</p>
<p>Hypothesis: We basically considered the simplest function definition for each input configuration and then merged them all, leaving aside some differing components.</p>
<h1 id="skill-acquisition">Skill Acquisition</h1>
<h2 id="skill-acquisition-hypothesis">Skill Acquisition: Hypothesis</h2>
<p><strong>Hypothesis</strong>: Skill you’re trying to learn, have a “unit test” for it -&gt; know whether you have actually learned it or not</p>
<p>Skill you’re trying to learn, don’t have a “unit test” for it -&gt; don’t know whether you have actually learned it or not</p>
<p>Skill you’re trying to maintain, run your “unit test” for it -&gt; know whether you still have it or not</p>
<p>Skill you’re trying to maintain, don’t run your “unit test” for it -&gt; don’t know whether you still have it or not</p>
<p><strong>Hypothesis</strong>: Situations, possible actions, situation-action associations - learn how to apply the actions to anything and then store the right action for each concrete situation -&gt; skill acquisition.</p>
<h2 id="learning-abstract-ideas">Learning Abstract Ideas</h2>
<p><strong>Hypothesis</strong>: Procedure you want to learn as skill, refactor it, make flashcards as unit tests for the different configurations -&gt; build the cue-memory associations.</p>
<p>Test: Making a junction tree out of a Markov random field - “first high-level step” -&gt; “variable elimination”, etc.</p>
<h2 id="fluency-and-flashcards">Fluency and Flashcards</h2>
<p><strong>Hypothesis</strong>: Test yourself using flashcards repeatedly (overlearning) -&gt; high fluency.</p>
<p>Test: Reviewing flashcards for SML final exam - went from 27 seconds per flashcard to 8 seconds to 5 seconds. For the causality midterm - went from 30 seconds per flashcard to 9 seconds to 4 seconds! – tested again and again - high fluency.</p>
<h2 id="skill-acquisition-tests">Skill Acquisition: Tests</h2>
<p>Test: I want to reinforce good behaviour. Am I doing that? (Too vague, I suspect.)</p>
<p>Test: I learned about inadequacy analysis. Do I think about the amount of work required to get some value when analyzing HP fanfiction (like in Eliezer’s Hero Licensing)? – Is this a good unit test? I don’t know.</p>
<p>Test: The classic graph for front-door criterion - will you apply the front-door criterion? I suspect that I will remember the solution directly.</p>
<p><strong>Question</strong>: How to avoid <strong>remembering</strong> the solution and actually <strong>generating</strong> it?</p>
<p>Test: Reinforcement - I give away my ideas for free thus reinforcing freeloading.</p>
<p><strong>Question</strong>: How to remember to do stuff on specific cues? Can you have unit tests for that?</p>
<p>Test: People come up with some suggestion - I can either reinforce or punish. Choose one of the four options. – just four possible abstract actions. However, there are a lot of concrete situations, like “when something falls short of your standard” or “thought about past action” or “someone tries to manipulate you”. Store the right action for each situation based on careful analysis or just feedback.</p>
<h2 id="motivation-aka-ignition-close-positive-exemplars">Motivation aka Ignition: Close Positive Exemplars</h2>
<p><strong>Hypothesis</strong>: See someone similar to yourself achieve great things i.e., close positive exemplar -&gt; feel that you could do it too if you made those small changes.</p>
<p>See someone dissimilar to yourself achieve great things i.e., distant positive exemplar -&gt; feel that they must have some special “aura of destiny” and that you couldn’t do it no matter what.</p>
<hr />
<p>Test: Me and Samsung Patrick. Korean female golfers and the first one. – close positive exemplar.</p>
<p>Test: Einstein. Mad scientists like Rick or whoever. “Geniuses” like the famous startup founders who talk weirdly and wear sweatshirts. Mathematical “geniuses” who look and act completely differently from normal people. “Smart” people using big words and an affected American accent - all to say that restore() simply sets the <strong>one</strong> bit back to what it was. – distant positive exemplars. Feel like I could never <em>be</em> like them. But I don’t have to <em>be</em> like them, I have to <strong>do</strong> what they did. And for that, I don’t have to emulate all their other characteristics.</p>
<h1 id="programming-for-minimum-interface-at-speed">Programming for Minimum Interface at Speed</h1>
<h2 id="look-at-the-input-configurations">Look at the Input Configurations</h2>
<p><strong>Hypothesis</strong>: pure function, know all possible input configurations for which the output is different -&gt; know test cases; clear how to proceed.</p>
<p>pure function, don’t know all possible input configurations for which the output is different -&gt; don’t know all test cases; not clear how to proceed.</p>
<p>impure function, know exactly where it will be called and what you expect (thus, know all possible input configurations for which the output is different) -&gt; know test cases; clear how to proceed.</p>
<p>impure function, don’t know all the places where it will be called and what you expect (thus, don’t know all possible input configurations for which output is different) -&gt; don’t know test cases; not clear how to proceed.</p>
<p>two input configurations, don’t know if they are supposed to give the same output or not, plan for both -&gt; can choose the correct one once you get feedback.</p>
<p>two input configurations, don’t know if they are supposed to give the same output or not, plan for neither -&gt; confused even after feedback?</p>
<p><strong>Hypothesis</strong>: Concrete walk-through, toggle each variable (come up with alternatives for each concrete value) -&gt; get possible input configurations.</p>
<hr />
<p>Test: <code>org-autoclock</code> – crystal-clear after I wrote out the configurations.</p>
<pre><code>Three variables: task, clock, file

no clock, task file -&gt; ask for org task
no clock, not in task file -&gt; do nothing
clocked in, task file -&gt; resume if needed
clocked in, not in task file -&gt; clock out if needed
clocked out, task file -&gt; resume
clocked out, not in task file -&gt; do nothing</code></pre>
<p>Test: unclear about vcreate and what it actually does - well, hsize can be 100, 300, or 1M. What to do for each case? Next, allocate_bs may return SYSERR - what to do then? – write input configurations -&gt; clear!</p>
<p>Test: <code>deallocate_bs</code> - not sure of all the places where it is called. I can see that it is called when a process is killed. But where else? I feel unsure. – impure function, don’t know all possible input configurations.</p>
<p>Test: Haskell - list recursion - either empty or head and tail - clear. – pure function - know all possible configurations.</p>
<p>Test: OS HW3 - <code>open backing store</code> - don’t know whether more than one process can access the same backing store. If so, then I have to handle the case where multiple processes try to access the store and own different pages in it. If not, then I don’t have to worry about any of that. – don’t know all possible input configurations for which output is different. If one process, then no matter what, we know that the behaviour is the same simple thing. If multiple processes, then we know that the behaviour depends on which process is asking for what page and whether somebody else is accessing the store right now.</p>
<p>Test: OS HW3 - don’t know whether hsize can be more than 1600 or not. Every other doubt stems from this uncertainty. – if hsize is only within 1600, then I know what to do. If not, then I don’t know what to do, but I can find out. Clear.</p>
<p>Test: OS HW3 - What worked, I think, was to have a concrete walk-through. That told me where there could be potential hotspots.</p>
<p>“You want to read from some address in your private heap. [might want read from elsewhere] (You’ve already used vgetmem to allocate the memory. [might not have used vgetmem yet]). First, there will be a page fault because you’ve never accessed that page before [might have accessed that page before and it might be present or not]. So, you will allocate one frame for the page table and then one frame for the page itself [may not need to allocate one frame for the page table]. And then copy that page from the backing store [or just don’t]. There will always be a free frame available, so no problem [there may not be a free frame available, in which case, problem].” – Input configurations - want to access memory within your private heap or not; have used vgetmem or not; have accessed page before; is present in memory; need to allocate frame for page table; copy from backing store or don’t; free frame available or not. Also, it’s one process right now. What if you have multiple processes?</p>
<h2 id="debugging-look-at-the-diffs">Debugging: Look at the Diffs!</h2>
<p><strong>Hypothesis</strong>: don’t know the cause of something, have the source code and can run interventions (aka <strong>debugging</strong>), look at your <strong>diff</strong>, list all your assumptions or toggle your diff till you get a “yes” -&gt; figure out which assumption is causing your error.</p>
<p>debugging - read your diffs line by line -&gt; notice what changes you made that could have caused the error.</p>
<p>debugging - just try different inputs without looking at the diff -&gt; find it harder to come up with the right inputs.</p>
<hr />
<p>Test: Tried writing at an address but the CR2 value showed some other address. Turned out that I had interpreted the output as hex when it was actually a long int! – toggling my diff would have helped.</p>
<p>Test: Re-read my buggy page directory setup code - discovered my errors. – read the diff line by line.</p>
<p>Test: Process wasn’t receiving message from parent. Tried lots of variations. Finally realized that I wasn’t even resuming the process. – didn’t look at the diff.</p>
<h2 id="complex-diffs-toggling-a-lot-of-variables">“Complex” Diffs: Toggling a Lot of Variables</h2>
<p><strong>Hypothesis</strong>: Diff toggles a lot of variables -&gt; hard to predict what the output will be.</p>
<p>Diff toggles a few variables -&gt; easier to predict what the output will be.</p>
<hr />
<p>Test: Lots of changes in my Emacs folder - don’t know what leads to what. – lots of variables changed - I took .emacs.d/ off the load-path, moved my personal elisp files into one folder, deleted the old lisp packages I was storing manually and instead got them from the package manager, and used <code>(require 'foo-feature)</code> instead of loading its file manually. Any of them in any combination could cause problems!</p>
<p>Test: Exactly one section changed in my one-button change essay - I know exactly what that does to the essay. – “look at diffs” - ok that affects my model of how to debug something, but not my ideas about refactoring or programming to an interface.</p>
<h2 id="confusion-look-at-the-diffs">Confusion: Look at the Diffs!</h2>
<p><strong>Corollary</strong>: Went from not confused to confused, get the specific changes (<strong>diffs</strong>) that caused the problem -&gt; need to learn about the effects of a very few variables.</p>
<p>Went from not confused to confused, don’t know which specific changes caused the problem -&gt; feel like you need to learn about a lot of variables.</p>
<p><strong>Lesson</strong>: Start with something you’re not confused about and take it from there.</p>
<hr />
<p>Test: Was following along the causal RL lecture till the q_i’s started coming in. Basically, I went from “not confused” to “confused”. Earlier, my mental model - my program - passed the tests of predicting the correct answer. But now, it couldn’t. So, I needed to look at the diff and figure out which change broke my model. – Got the specific diff that broke my model.</p>
<p>Test: Confused about all causality papers. Don’t think I’ve been un-confused about “all causality papers”. Feel like I will have to read a lot of papers to become un-confused about “causality papers”.</p>
<p>Test: OS HW3 - really, really confused about what to do. No clear idea about how to proceed. – Okay. Narrow down the diff. What worked, I think, was to have a concrete walk-through. That told me where there could be potential hotspots (for example, if there were no free frame available, I’d have to replace a page).</p>
<h2 id="differing-predictions-well-look-at-the-diffs">Differing predictions: Well, Look at the Diffs!</h2>
<p><strong>Hypothesis</strong>: Don’t know the cause of something, don’t have the source code and can’t run interventions, come up with possible causes - get their differing predictions -&gt; figure out the right cause.</p>
<p>Want to know where I know more than others - get their differing predictions (by taking the diffs of our proposed explanations or just the books we’ve read) -&gt; figure out problems that they just can’t solve.</p>
<hr />
<p>Test: Why did Goldenfold say “5 more minutes of this and I’ll get mad”. Two possible causes. We can look at their differing predictions to get feedback. – don’t have the source code and can’t run interventions; but can look at differing predictions.</p>
<p>Test: What do I know about “cognitive psychology” that others don’t? How to get differing predictions? They talk about “complex neural networks” and “network of ideas”. I don’t (I know about how it’s cue-memory associations all the way down). They talk about how forgetful they are, I don’t (I know about the exponential decay curve). They think re-reading is good enough. I don’t (I know that you need to test for recall). – Their proposed explanations are different from mine in these ways. From these, I can come up with differing predictions - people who test themselves will actually learn things.</p>
<h2 id="speed-coding-hat-vs-refactoring-hat">Speed: Coding Hat vs Refactoring Hat</h2>
<p><strong>Hypothesis</strong>: adding a new feature, one long chain of function calls -&gt; will pass the test case (one branch), very little time, will not overengineer. Refactor -&gt; easier to test going forward -&gt; quick. h/t Kent Beck.</p>
<p>adding a new feature, abstract code (using separate functions or classes) -&gt; will pass the test case (one branch), will take more time because you’re changing the design too, may overengineer. Debugging -&gt; slow.</p>
<p>adding a new feature, optimized code (low-memory quick functions or detailed, convincing examples) -&gt; will pass the test case (one branch), will take more time because you’re changing the design at the same time you’re making it faster; may overengineer. Debugging -&gt; slow.</p>
<p><strong>Test</strong>: [2017-11-05 Sun] Tried to write quick and dirty code to pass one simple unit test. Nearly got a heart attack in the process. Here it is:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> batsman_total(match, player):
	d <span class="op">=</span> match.match_details[<span class="st">'innings'</span>][<span class="st">'1st innings'</span>][<span class="st">'deliveries'</span>]
	<span class="bu">print</span>(d)
	total <span class="op">=</span> <span class="dv">0</span>
	<span class="cf">for</span> ball_num, ball <span class="op">in</span> d.items():
		<span class="cf">if</span> ball[<span class="st">'batsman'</span>] <span class="op">==</span> player:
			total <span class="op">+=</span> ball[<span class="st">'runs'</span>][<span class="st">'batsman'</span>]
	<span class="cf">return</span> total</code></pre></div>
<p>I couldn’t bring myself to write <code>total += anything</code>. Felt so fucking gauche. Ditto for the for-loop and direct testing (<code>if ball['batsman'] == player</code>). I felt like reaching for a map and filter. But that would probably be overkill. I needed to bring myself to cut through to the actual output.</p>
<p>But this code is fine for my purposes! I usually overengineer. I can code faster by writing quick and dirty code and then refactoring, instead of throwing in abstractions like <code>map</code> and <code>filter</code> and so on, especially in a predominantly-imperative language like Python.</p>
<p>Test: Want to write down my completeness proof in LaTeX - hesitating because I feel like I need to write a complete report that flows from start to end, and maybe have diagrams and stuff. No! All I need to write is the proof alone. Everything else can come later. – one thing at a time.</p>
<p>Test: Spent the last one hour coming up with a crystal-clear model that would show how <span class="math inline">\(U_Z\)</span> and Y are related even though that’s not the point of my proof. Dammit. – I was trying to abstract? Was I? I was trying to optimize for a <strong>great</strong> proof - one that would convince any snotty critics. But I didn’t really need that. This isn’t my final draft; this is just a proof of concept.</p>
<p><strong>Test</strong>: Others seem to finish assignments sooner than me. Is it because they’re writing different code than me or because they’re writing the same code faster?</p>
<p>Test: OS HW3 - I’m taking a long time to pass each test. Is it some essential difficulty of the problem (with respect to my current skill) or am I just being slow somehow?</p>
<h2 id="high-level-design-needs-an-integration-test-maybe-with-mocking">High-level Design needs an Integration Test (maybe with Mocking)</h2>
<p><strong>Corollary</strong>: Have integration test with expected output (maybe mocking out each lower-level function for the particular test input), get high-level design -&gt; low uncertainty.</p>
<p>Don’t have integration test, get high-level design -&gt; high uncertainty.</p>
<hr />
<p>Test: OS HW3 - change design of my paging code - don’t know which one will be better (and still pass all tests). Don’t know how to implement free-frame list in the best way or how to decouple the heap and backing store from the rest of the program, etc. – didn’t have any integration test, lots of uncertainty.</p>
<p>Test: OS HW2 - pipes - knew how the high-level pieces were going to fit together. Basically, didn’t have to do any <strong>high-level design changes</strong>. Just implement pipgetc, pipputc, etc. and the test code would simply use a pipe like a normal device. – didn’t need to change the high-level design.</p>
<p>Test: OS HW3 - tried one example of virtual memory page access - got the general idea of how control flowed. Got the high-level design (heap was used just to allocate memory, backing store was really used only when there were insufficient frames). – integration test helped me get the answer quickly.</p>
<h2 id="integration-test-followed-by-unit-tests">Integration Test followed by Unit Tests</h2>
<p><strong>Corollary</strong>: Write one failing integration test that doesn’t have any branches anywhere, come up with high-level design, write unit tests for each module, put it together -&gt; high-level design at speed, module design at speed, correctness.</p>
<p>Write just the failing integration test, no unit tests -&gt; may not handle certain cases - errors, high uncertainty about modules - slow, hesitate to change code.</p>
<p>No integration test, write just unit tests -&gt; uncertainty about design - slow, don’t know how to proceed.</p>
<hr />
<p>Test: OS HW3 - obtaining a free frame - if page was dirty, write it to the backing store. – got the high-level design, but don’t know if my <code>get_new_frame</code> function handle possible cases well. Hesitant to make global changes like adding a new field to <code>invpt_entry</code>.</p>
<h2 id="implementing-a-spec-focus-gambling">Implementing a Spec: Focus-Gambling</h2>
<p><strong>Hypothesis</strong>: Given high-level design, pseudo-code that you know is correct, implement first, write tests later, put only as much confidence in your program as the number of tests you pass -&gt; get correctness first and good module-level design later -&gt; low uncertainty about each function because you already know the pseudo-code, quick.</p>
<p>Given high-level design, pseudo-code that you know is correct, test-driven design -&gt; get correctness and good module-level design at the same time -&gt; low uncertainty, but slow because you have to code step-by-step.</p>
<hr />
<p><strong>Test</strong>: OS HW3 - I’m given the pseudo-code for page fault handling and free frame obtaining. But I’m still taking a long time to “design” the free-frame obtaining code correctly. – slow because you’re trying to get correctness and good design at the same time.</p>
<p><strong>Test</strong>: pipcreate - all possible configurations handled, but it took a long time (~25 hours) before I could pass even one shell integration test. – was going test by test.</p>
<h2 id="red-green-refactor-vs-focus-gambling">Red-Green-Refactor vs Focus-Gambling</h2>
<p>Test: Implementing the pseudo-code first and then covering branches with tests violates red-green-refactor. Then again, focus-gambling itself violates red-green-refactor. You’re concluding first and running tests later.</p>
<h2 id="remember-to-refactor">Remember to Refactor</h2>
<p><strong>Hypothesis</strong>: After passing the test, reminder to refactor -&gt; refactor.</p>
<p>After passing the test, no reminder to refactor -&gt; don’t refactor.</p>
<hr />
<p>Test: initialize_nullproc_paging remained ugly. I didn’t refactor it. – no reminder.</p>
<h2 id="toggle-behind-an-interface-with-one-button">Toggle behind an Interface with One Button!</h2>
<p><strong>Hypothesis</strong>: Feature you want to toggle, hide the current feature behind an interface and toggle completely with one button -&gt; handle each use of the interface (read or write), don’t mix and match between the features, quick -&gt; no uncertainty, no errors.</p>
<p>Feature you want to toggle, don’t hide the current feature behind an interface or don’t toggle completely or don’t have just one button -&gt; may miss places where it is used, will take longer -&gt; uncertainty, errors.</p>
<p><strong>Hypothesis</strong>: Searching for all uses of the thing you’re toggling leads to recursive toggles.</p>
<hr />
<p><strong>Test</strong>: OS HW3 - massively confused. Don’t know how to implement <strong>page-directory switching</strong>. Don’t know what could go wrong. Don’t know all the places where page-directory could be <strong>used</strong> (and thus be messed up by me). - Try getting one integration test. If it breaks, you can always revert back to confusion. – It worked! All I had to do was add an entry to procent, initialize it during create, have pointers to the global page tables, set up procent for nullproc too, update the page directory entry in <code>page_fault_handler</code>, and simply load the directory upon context-switch. Basically, set up process page directory correctly for all processes (initialize, pointers to global page tables, null process); update it when needed; load it when needed.</p>
<p>Ah, fuck. I should have hidden <code>process.page_directory</code> and made them come for it. That way I would have known who wanted to read it and who wanted to write it. What a way to drive in an age-old lesson - program to an interface, not an implementation. I forgot it when it came to OS development in C.</p>
<p>Explanation: I had the integration test of two processes writing to the same virtual address. When it came to the first 4096 pages, both the alternatives would work the same. They would differ only when going beyond the initial pages. The default alternative would overwrite one of the values in the null process’ page directory. My new per-process page directory alternative would have separate page directories for them and thus write separate values. So, pdbr should point to the current process’ page directory. Also, as per the integration test, the page fault handler should also use the current process’ page directory.</p>
<p>Hmm… I should basically have grepped for <code>page.*directory</code> and looked at everything that depended on it.</p>
<p>Look at the interface for everything.</p>
<p>The kernel’s view of the “page directory” - <strong>all</strong> it knew or cared about was CR3. So, if I wanted it to use a different page directory, I needed to change CR3. Where? At the end of <code>resched</code>.</p>
<p>Similarly, the OS’s view of the page directory - right now, everything depended directly on <code>page_directory_nullproc</code>. That was the only page directory in existence. I wanted to propose an alternative to it - a per-process page directory. So, I should have hidden it behind an interface and then toggled to the per-process page directory without anyone being any wiser.</p>
<p>Actual explanation: Feature I wanted to toggle - global page directory vs per-process page directory; didn’t hide the global page directory behind an interface -&gt; missed places where it was used (like the page fault handler and resched).</p>
<p>Test: Didn’t hide procent behind an interface when toggling the feature “no page_directory field” to “page_directory field” -&gt; missed places where it was used (like create, initialize, and global initialize).</p>
<p>Test: I forgot to update nullproc’s page directory. Why? Because I updated procent without hiding it behind an interface. So, I didn’t catch all its users, in particular <code>initialize</code>. I should have looked for everything that initialized procent (since nothing would read or write to <code>page_directory</code> yet). – Caused errors.</p>
<p>Test: When toggling global page directory with per-process page directory, I have to toggle the definition of procent, which requires me to seek all uses of procent. Similarly, toggling memlist involves toggling meminit, which requires finding out all the places where meminit is called.</p>
<h2 id="abstract-dont-accept-all-the-information-youre-given">Abstract: Don’t Accept all the Information you’re Given</h2>
<p><strong>Hypothesis</strong>: Desired output, accept all the information given (deal with a concrete type) -&gt; have to deal with more input configurations.</p>
<p>Desired output, abstract the inputs using the possible outputs (deal with an abstract type) -&gt; have to deal with fewer input configurations.</p>
<hr />
<p>Test: <code>findPerson</code> vs <code>find</code>. – Have to deal with Person being male or female.</p>
<h2 id="decompose-the-input">Decompose the Input</h2>
<p><strong>Hypothesis</strong>: Input, treat it like some monolithic data structure -&gt; have to deal with a lot of input configurations.</p>
<p>Input, treat it like some decomposable data structure (where the parts are decoupled) -&gt; fewer input configurations.</p>
<p><strong>Hypothesis</strong>: Sum-product type, decompose -&gt; easily done.</p>
<p>Some other type, decompose -&gt; pretty hard.</p>
<p><strong>Corollary</strong>: Decompose reality.</p>
<hr />
<p>Test: Guy <a href="http://www.jamesshore.com/Agile-Book/test_driven_development.html">talking about TDD</a> - <code>parseQuery</code> in Java took several red-green-refactor cycles. I did it in one line of Haskell and it was right too. Why? Why didn’t I need all the extra unit tests? I suspect that most of them were already covered by the functions I was composing. (The empty string one wasn’t.) – The guy was treating <code>QueryString</code> like some monolithic data structure that could have any number of possible configurations. I was treating it like a bunch of strings separated by “&amp;” and then separated by “=” within those.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span>
m <span class="fu">=</span> M.fromList <span class="fu">.</span> map ((\[x, y] <span class="ot">-&gt;</span> (x, y)) <span class="fu">.</span> splitOn <span class="st">&quot;=&quot;</span>) <span class="fu">.</span> splitOn <span class="st">&quot;&amp;&quot;</span> <span class="fu">$</span>  <span class="st">&quot;name1=value1&amp;name2=value2&amp;name3=value3&quot;</span></code></pre></div>
<p>Maybe these were well-worn paths that many programmers had already trodden. It would be a mistake to write fresh unit tests for them, as if you were completely uncertain as to their behaviour.</p>
<p>Observation: <code>parseQuery</code> is way too specific. What you really have is a bunch of a’s with delimiters. Writing a specific function for that is just stupid.</p>
<h2 id="chain-decompose-transform-compose">Chain = Decompose, Transform, Compose</h2>
<p><strong>Hypothesis</strong>: Chain of functions -&gt; each function either decomposes the previous data structure or composes it into something bigger or transforms each part without composing it.</p>
<hr />
<p>Test:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">callGrepOnFile p <span class="fu">=</span> unlines <span class="fu">.</span> grep p <span class="fu">.</span> lines

<span class="co">-- Read the files, grep each of them, and combine the results.</span>
callGrep p fs <span class="fu">=</span> fmap (concat <span class="fu">.</span> map (callGrepOnFile p)) <span class="fu">.</span> mapM readFile <span class="fu">$</span> fs</code></pre></div>
<p><code>lines</code> breaks down the string into a bunch of lines (each of which is simpler than the whole file and is independent of the rest). <code>grep p</code> transforms the lines into some other set of lines (just a subset). <code>unlines</code> composes the bunch of lines into a string.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mapM<span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</code></pre></div>
<p>Next, <code>mapM readFile</code> transforms a list of files into a list of monads and then composes those monads to get an overall monad. Basically, you can see it as composing a bunch of files. <code>fmap</code> transforms part of a structure without touching the rest. <code>map (callGrepOnFile p)</code> transforms each element of that part-structure using <code>callGrepOnFile</code>. Finally, <code>concat</code> composes those elements into a valid part-structure.</p>
<h2 id="minimum-interface-at-speed-more-hypotheses">Minimum Interface at Speed: More Hypotheses</h2>
<p>want to handle a new input configuration (add a new feature) - get a failing test first -&gt; speed (no abstract thinking).</p>
<p>new feature, pure function, write automated failing test -&gt; speed.</p>
<p>new feature, impure function, manual failing test -&gt; speed.</p>
<p>failing test - pass it by writing a quick and dirty chain of function calls, no branches -&gt; correctness, speed.</p>
<p>test passed - refactor your code -&gt; speed, quality (more understandable, reusable, and modifiable).</p>
<p>manual test passed - write automated test -&gt; speed, quality. (??)</p>
<p>writing code - do you have a failing test for it? -&gt; write useful code.</p>
<p>question about one small part, write a test in a scratch file -&gt; get answer quickly (since you’re only changing a few variables instead of the whole original program).</p>
<h2 id="other-tests">Other Tests</h2>
<p>Test: page table code in HW3 - wrote hopelessly buggy pointer arithmetic code. Zero tests.</p>
<p>Test: Wasn’t sure how to condition on a variable when there were two factors. Did the derivation in a scratch page - got the answer!</p>
<p>Test: Wasn’t sure how to do pointer arithmetic on an array. Ditto for bit shifting. Results were shocking! – yup.</p>
<p>Test: HW3 - no unit tests, just constant rebooting; still discovered all my bugs by reading the diffs. – read diff line by line.</p>
<p><strong>Test</strong>: Trying to write org-autoclock - should I create an automated test or do a manual test? Which would lead to faster (quick-and-dirty) code?</p>
<p>Test: org-autoclock - manual test - fast; try to write automated test - lost! – impure function.</p>
<p>Test: function to paste joined text - automated test - fast – pure function.</p>

<div class="info">Created: October 20, 2017</div>
<div class="info">Last modified: December  7, 2017</div>
<div class="info">Status: in-progress notes</div>
<div class="info"><b>Tags</b>: notes, one-button</div>

<br />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'spkrationalitytrainingground'; // required: replace example with your forum shortname
    var disqus_identifier = '/one-button-change.html';
    var disqus_title = 'One-Button Change';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
	var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
