<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/png" href="./images/favicon-32x32.png" sizes="32x32" />
	<link rel="icon" type="image/png" href="./images/favicon-16x16.png" sizes="16x16" />
        <title>One-Button Change - SPK's Rationality Essays</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/highlight.css" />

	<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
	<!-- <script type="text/javascript" src="/js/header-links.js"></script> -->
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<link href="atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed" />

	<!-- Google Analytics stuff -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-51321929-1', 'pradeep90.github.io');
	  ga('send', 'pageview');

	</script>

    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Rationality Essays</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./notes.html">Notes</a>
                <!-- <a href="/about.html">About</a> -->
                <a href="./archive.html">Archive</a>
		<a href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
            </div>
        </div>

        <div id="content">
          <h1 id="post-title">One-Button Change</h1>

            <!-- <center><img src="https://fbcdn-sphotos-d-a.akamaihd.net/hphotos-ak-prn1/t31.0-8/p600x600/10257116_10202295769100492_2438594605053717342_o.jpg" height="400" width="300" class="sujeet-pic" alt="Sujeet pic" /></center> -->

<h1 id="one-change-at-a-time">One Change at a Time</h1>
<p>Hypothesis: We get evidence about our program by running it on some input or by type-checking it.</p>
<p>Hypothesis: We can process evidence about one variable at a time. Beyond that, we get confused.</p>
<p>(Yes, we can get lucky with multiple changes, but that won’t pay off on average.)</p>
<p><strong>Hypothesis</strong>: One key factor in programming efficiently - aka processing evidence about our program - is to make one high-level change at a time before you get evidence.</p>
<p>This means that you should be able to choose between your two design choices, say process scheduler A and process scheduler B with just one small change. No changing variable assignments in three different places, not hasty commenting of 15 lines of code, no tweaking of multiple configuration files - just one button press.</p>
<p>(Why would this weird condition help write programs faster? We’ll see.)</p>
<h1 id="how-to-program-with-one-button-changes">How to Program with One-Button Changes</h1>
<p>How will this affect the way you code?</p>
<p>For one, you can’t change multiple lines of code within some other function. Because then, if you wanted to roll back those changes, you would have to edit multiple lines.</p>
<p><strong>Corollary</strong>: Any change you make must be encapsulated within a new function before you run the program.</p>
<p>Now, what if you wanted to switch from scheduler A to scheduler B? Sure, A is within a function that you can comment out (or in a class method that you can change at runtime via polymorphism). But B could be a bunch of lines of code strewn across your project. So, to switch to B, you would have to uncomment all those lines. Not allowed.</p>
<p><strong>Corollary</strong>: Any alternatives must be easily switchable (when you run the program).</p>
<p>In OOP, you would do this via interfaces or inheritance, where you simply switch the class that is implementing the interface, and the caller code is none the wiser. In functional programming, you simply switch to another value of the same type or type class.</p>
<p>What happens when you’re starting out with a new feature, like pipes in an operating system (completely hypothetical example; not related to my coursework at all)? If you press the button, you will switch to your neatly encapsulated function or class that implements pipes. But what if you want to go back to a pipe-less operating system, just to check for correctness or performance? You may not be able to, if you have pipe initialization and destruction code lying around, and if processes have information about pipes they may own.</p>
<p><strong>Corollary</strong>: You must have a default alternative for every choice (when you run the program).</p>
<p>For example, if you implemented pipes, your default would be the non-piped version. (Again, you should be able to switch between these two in one button-press.) If you implemented a new time-share scheduler for the operating system, you must encapsulate the original scheduler as a default alternative.</p>
<p>Likewise, if you’re setting out on a “complex” change, you should have a default stub of it that does nothing.</p>
<h1 id="empty-inside">Empty Inside</h1>
<p>Question: What if you’re not creating alternatives, like two types of schedulers, but rather just one algorithm, like pipes for an operating system?</p>
<p>Question: What kind of change are you making at each point? What was the program like earlier and what is it like after the change?</p>
<p><strong>Hypothesis</strong>: You should have a default stub that has the <em>same type</em> as your final code, but doesn’t affect the behaviour of the system. Then, you should have a one-button change that allows you to switch to the final code.</p>
<p><strong>Corollary</strong>: Your unit test for a feature should <em>fail</em> when you switch to the default implementation and <em>pass</em> when you switch to the feature-filled implementation. As usual, it should be a one-button change.</p>
<p><strong>Hypothesis</strong>: Add unit tests (or assert contracts) for everything that your new feature changes.</p>
<p>Hypothesis: Having a one-button change between feature and no-feature allows you to roll it back quickly to see what was caused by the feature itself as opposed to the earlier code.</p>
<p>For example, my test for pipe deletion passed even though my <code>pipdelete</code> function was empty! I’d mixed up types in other places, which meant that my desired pipes were not getting initialized in the first place. So, the test passed whether or not I implemented my <code>pipdelete</code> feature. Good to know. Otherwise, I’d be scratching my head wondering which of my seven changes in different parts of the system had caused the bug.</p>
<h1 id="upshot">Upshot</h1>
<p>What do all those straitjackets get you? I’m not fully sure. We’ll find out the usual way: good ol’ fashioned experimentation.</p>
<p><strong>Hypothesis</strong>: Single, easily-reversible change -&gt; any behaviour that is in the program with the feature on and not in the program with the feature off must be caused (at least partly) by the feature.</p>
<p>Contrast that to shotgun change, where you aren’t sure which change broke your code.</p>
<p>Hypothesis: First-class objects -&gt; make it easier to switch.</p>
<p>For example, a value or function or object of the same type.</p>
<p>Question: Do you really need to rollback that often? Yes, you will want to toggle a new feature while implementing it. But after implementing A, B, and C in sequence, will you need to check out AB’C? Or will you treat the existing program as correct and indivisible?</p>
<p><strong>Observation</strong>: Will need to rollback if you think of a test or find a bug after the implementation.</p>
<p>Hypothesis: Hard to come up with good tests or properties in advance.</p>
<p>Hypothesis: If you come up with a test or property in the future, you need to toggle back through your features to see when it stops passing.</p>
<h1 id="multiple-possible-causes-are-hard-to-reason-about">Multiple Possible Causes are Hard to Reason About</h1>
<h2 id="intermediate-states-are-hard-to-reason-about">Intermediate States are Hard to Reason about</h2>
<p>Observation: Suppose you had to do a number of things to reset a system. You could miss a step or two and land up with “weird” behaviour.</p>
<p><strong>Hypothesis</strong>: Multiple changes when trying to go to a desired state -&gt; could leave the system in a state that is “hard to reason about”.</p>
<p>For example, you need electricity, intact wires, a working bulb, and a switch in the ON state to make a light bulb glow. If however, there’s a problem with the bulb or if you forgot to pay your electricity bills, the bulb won’t glow. But you don’t know exactly what caused the problem.</p>
<h2 id="minimize-number-of-possible-causes">Minimize Number of Possible Causes</h2>
<p>Observation: The problem is that you can’t <em>identify</em> the possible causes. You become highly uncertain.</p>
<p><strong>Hypothesis</strong>: “Processing evidence” = figuring out which states of the system could have caused the given output.</p>
<p>This is what Bayes theorem talks about.</p>
<p><strong>Hypothesis</strong>: Humans can’t handle a bunch of possible causes leading to the same output.</p>
<p>(That’s why they lump them in the same category.)</p>
<p>Hypothesis: Humans like to toggle one variable at a time because they can’t handle it if one of several things could have caused the output.</p>
<p>Observation: When there’s a lot of stuff that we’ve changed about a system and the output is not anything we can normally explain, we consider the system “messy” or “chaotic”.</p>
<p><strong>Hypothesis</strong>: “Chaotic mess” = can’t tell which state caused the given output (because there are too many of them).</p>
<p>Classic example: when I changed a bunch of scheduler code and couldn’t tell where the bug was.</p>
<p><strong>Hypothesis</strong>: Aim of category design = <em>minimize</em> the number of possible causes of any outcome.</p>
<p>For example, test if there’s electricity at the bulb socket. Then, try to plug in the bulb. If there was no electricity initially, then the earlier part of the system is broken. If there is electricity and if the bulb works, then there’s no problem. If it doesn’t, then we know that the bulb is what is broken.</p>
<h2 id="debugging">Debugging</h2>
<p>Hypothesis: Aim of programming: Fix undesirable output.</p>
<p>Fixing undesirable output would involve figuring out its cause and then changing it. The problem arises when you can’t figure out the cause of some undesirable behaviour.</p>
<p><strong>Hypothesis</strong>: Debugging = figuring out the <em>cause</em> of some undesirable behaviour.</p>
<p><strong>Hypothesis</strong>: We spent a lot of time, maybe most of our time, in debugging.</p>
<p>Observation: Why do I feel low in confidence sometimes? Don’t quite know. Is it mostly because I haven’t exercised or because I’m not focusing on the topics I care about or don’t have a “great” social life? Don’t know. I’m not able to do backward inference on my social performance.</p>
<h2 id="break-the-output-into-pieces">Break the Output into Pieces</h2>
<p>Hypothesis: To find out the cause of some output, break it into pieces according to known causes and thus narrow down the culprits.</p>
<p>For example, if you know that the output list was mapped from some input list, then an error in the 5th element must have been due to the 5th element of the input list.</p>
<h2 id="backward-inference">Backward Inference</h2>
<p><strong>Hypothesis</strong>: This is backward inference.</p>
<p>And it’s hardest when you have made a lot of changes before observing some understandable output. For example, when working on my OS assignment, I changed the scheduling code in a lot of places and then ran my test case. The OS hung after the initial output. Why? I had no clue.</p>
<p>Observation: This is what House does. He look at symptoms and infers the diseases that could have caused them. (Fictional evidence, but representative of doctors who do, in fact, diagnose patients.)</p>
<p>Laymen or even his fellow doctors are often puzzled by the same observations. (Fictional evidence.)</p>
<p>Observation: Mystery-solving (a la Hercule Poirot or Sherlock) is all about backward inference.</p>
<h2 id="strong-evidence">Strong Evidence</h2>
<p>Hypothesis: Strong evidence = something that tells you the cause is in <em>this</em> part of the system, not that one.</p>
<p>This is what we desire. We want to narrow down the suspects.</p>
<p><strong>Hypothesis</strong>: If you can switch easily (and reliably) between two alternatives, you can observe the difference in output, and thus figure out where the cause lies.</p>
<p>Question: What if you could run the program only once? How could you design your program to minimize the number of possible causes?</p>
<p><strong>Question</strong>: What sort of test cases should you design so that you get discerning output?</p>
<h2 id="how-do-we-build-a-system-forward-backward-inference">How do we Build a System? Forward + Backward Inference</h2>
<p><strong>Hypothesis</strong>: We want our system to have some target property. So, we change some variables in the hope of hitting the target property. Then, we observe the actual output and infer which variables we should have changed differently. And so it goes.</p>
<p>It’s forward inference to compute the actual output (which the computer automates for us, in the case of programming) and backward inference to figure out which variables we need to change further.</p>
<p>Hypothesis: The problem, of course, is when you have a lot of other variables in between.</p>
<p>For example, I just wanted to change the scheduling algorithm of the XINU OS. It was a simple enough conceptual change, but because my change affected a lot of other variables (like whether interrupts were disabled or enabled, polled I/O vs blocking I/O, null pointer errors, etc.) I couldn’t tell exactly which of my changes had caused what.</p>
<h2 id="unit-tests-minimize-number-of-causes">Unit Tests minimize Number of Causes</h2>
<p>Hypothesis: Unit tests minimize number of causes because their output depends only on one function or class.</p>
<h1 id="big-functions-are-hard-to-reason-about-too">Big Functions are Hard to Reason about too</h1>
<p>Observation: Bunch of journal notes and essays. Don’t know exactly what they contain or what they advise for some problem I face. Clearly, a “chaotic mess”.</p>
<p>Observation: Unfamiliar function - can’t tell what it does.</p>
<p>Observation: If I have a variable that I can change to switch the scheduler from a time-share scheduling algorithm to a proportional-share algorithm, then I can kind of tell the difference in behaviour between the two.</p>
<p>Observation: But if I have three hundred lines of code spread over four files that are different between time-share and proportional-share scheduling algorithms, I find it much harder to predict the differences in behaviour.</p>
<p><strong>Hypothesis</strong>: Lots of possible input states and thus lots of possible output states -&gt; hard to infer forward or backward.</p>
<p>Why? Not quite sure. But if it’s an arbitrary function, then you have a lot of input-output mappings to remember. You’re liable to give up.</p>
<h1 id="restricting-yourself-to-one-button-changes-simplifies-your-model">Restricting yourself to One-Button Changes simplifies your Model</h1>
<p>Hypothesis: One-button change between alternatives -&gt; simpler type signature (A vs B -&gt; X vs Y).</p>
<p>Corollary: You won’t be able to make low-level predictions about, say, the exact priority of each process at each point of time, but you would be able to predict the high-level properties (such as, I/O-bound processes will go first in a time-share scheduler).</p>
<p>Corollary: One-button change between small set of high-level alternatives -&gt; <strong>cannot</strong> choose some arbitrary intermediate state.</p>
<p>Corollary: So, the output will always be that corresponding to one of the high-level alternatives. Much easier to infer forward or backward.</p>
<p><strong>Hypothesis</strong>: Allow yourself only one-button changes vs can change anything anywhere -&gt; far simpler model of the system vs lots of possible inputs and lots of possible outputs.</p>
<p>You’re restricting your set of possible interventions. Because you know you haven’t changed anything else anywhere, the only possible inputs are those defined by your high-level categories.</p>
<p>Hypothesis: Allow yourself only one-button changes -&gt; fewer possible interventions and thus fewer possible input states.</p>
<p><strong>Hypothesis</strong>: Number of possible interventions -&gt; number of categories.</p>
<p><strong>Hypothesis</strong>: Number of categories -&gt; number of possible input-output mappings -&gt; number of possible causes for any output and number of possible outputs for any cause.</p>
<h1 id="tests">Tests</h1>
<p>Observation: I have one test for each condition mentioned in the spec.</p>
<p>For example, “In any case, if the arguments are invalid, the pipe was already connected to other processes, or the state of the pipe does not permit connection, the system call returns SYSERR.” I have a test for each of them.</p>
<p><strong>Observation</strong>: Red-green saves my ass. I keep forgetting to add my new test case to the test list, and so it seems like the test has passed. Only when I make it <em>fail</em> do I realize my mistake.</p>
<p><strong>Hypothesis</strong>: To be sure that some output property is caused by your feature, toggle it and see whether the property toggles too.</p>
<p><strong>Observation</strong>: Tests bring out bugs that I would never have inferred.</p>
<p>For example, deleting a pipe caused a pipe to be in a non-active state when calling disconnect on the writer. Who knew?</p>
<p><strong>Hypothesis</strong>: How to write tests - look at the interface alone and analyze the different possible inputs.</p>
<p>For example, <code>pipe_disconnect_reader</code> cares only about the different states of the pipe (free, used, connected, writer disconnected, etc.), not about the rest of the system.</p>
<h1 id="handle-all-possible-high-level-inputs">Handle all possible High-level Inputs</h1>
<p><strong>Hypothesis</strong>: To be confident that you’ve written your function correctly, handle all the high-level categories of your input.</p>
<p>Corollary: Errors crop up when you omit some cases.</p>
<p>The most obvious case is forgetting to check for NULL. Another case is to handle all possible states of your input argument, like a pipe that is not connected to anything or a pipe that has been freed.</p>
<p>Corollary: Static type-checking helps you by making sure you handle all the possible input values, especially in the case of sum types like in Haskell.</p>
<p><strong>Corollary</strong>: You must yourself know what must happen for each input configuration.</p>
<p><strong>Lesson</strong>: Write your code one branch at a time. Write a unit test up-front to make sure you’re actually adding a feature.</p>
<p>You should change code only within one of the possible input categories. If you want to do something for input A, you must do something (maybe a dummy default action) for inputs B and C.</p>
<p>Corollary: That way, at each point, you can tell which value was caused by the branch for A and which one by the branch for B.</p>
<h2 id="what-is-the-next-unit-test">What is the Next Unit Test?</h2>
<p>Hypothesis: If you’re stuck, ask yourself what is the next unit test you want to pass.</p>
<h1 id="work-needed-is-proportional-to-number-of-test-cases">Work Needed is proportional to number of Test Cases</h1>
<p>Corollary: The total work you need to do depends on the number of branches you need to implement and the time it takes you to code and test each branch.</p>
<p>Observation: I didn’t even <em>know</em> how many branches I had to deal with. I couldn’t see them in my head when I thought about the problem of “implementing pipes for XINU”.</p>
<p>Corollary: Number of branches you had to implement = number of test cases.</p>
<p>So, use the test cases to determine the total work you had to do.</p>
<p>Corollary: Number of test cases is determined by the number of branches you need to implement. Make sure you have that many.</p>
<p>Hypothesis: If we assume that the time needed to make one unit test pass is constant, then the estimated time for the whole project should be proportional to the number of branches in each function (i.e., the number of test cases).</p>
<p>We can use that to estimate time needed.</p>
<h2 id="planning-fallacy">Planning Fallacy?</h2>
<p>Observation: I underestimated the number of test cases I would need to implement. Sometimes, I was so unsure that I needed to have unit tests for smaller things like adding a semaphore to my pipe entry, because I’d not used it before.</p>
<p>Observation: I didn’t even know what output I wanted from some function.</p>
<h1 id="callers-define-your-contract">Callers define your Contract</h1>
<p>Observation: Hard to change the behaviour of <code>pipe_set</code> without knowing how and where it’s been used. I don’t want to break its “contract”.</p>
<p>Hypothesis: If you had unit tests (and an assertion-based contract), you could just use that as your contract and change whatever you wanted as long as you didn’t break it.</p>
<h1 id="why-you-need-to-roll-back-sometimes">Why you Need to Roll Back Sometimes</h1>
<p>Observation: Error when trying to create a semaphore. No clue why.</p>
<p>Experiment: Didn’t change anything in the lower-level functions. Just toggled the high-level tests to see which combination broke it.</p>
<p>For example, I knew that running the 20 tests gave the error. Running 0 tests didn’t give the error. Running the first 10 didn’t either. Turned out running two particular tests together gave the error. Cool. That narrowed it down. (I was able to find out that I was initializing too many semaphores and thus running out.)</p>
<p>Imagine if I’d tried this without the high-level functions and had made changes here and there. I would have been overwhelmed within a few minutes. Guess how I know that? Because that’s what I started out doing. Only after half an hour or so did I wise up.</p>
<p><strong>Hypothesis</strong>: Need to roll back and toggle features when you have errors across functions.</p>
<p>Unit tests catch errors that are within a single function. For errors across functions, you need high-level toggling.</p>
<h1 id="backward-inference-1">Backward Inference</h1>
<p><strong>Hypothesis</strong>: This is how you do backward inference. You narrow down some combination of high-level causes and test them till you find one whose effect matches the observed output. After, that you narrow it down at the next level, thus keeping the “complexity” or number of possible causes limited at all times.</p>
<p>Observation: The key was that turning on all the high-level causes on gave you a positive answer (error) and turning them all off gave you a negative answer (no error). So, you could tell that the error must begin with some combination of causes between zero and everything.</p>
<h1 id="which-input-configuration-did-i-fail-to-handle">Which Input Configuration did I Fail To Handle?</h1>
<p>Observation: Notice that I didn’t exactly break any of my older unit tests. What I broke was the underlying code (<code>pipinit</code>), which was exacerbated by the fact that I ran so many tests and ended up creating too many semaphores.</p>
<p>Observation: I added a new property to the program (semaphores), which caused problems.</p>
<p>Observation: I failed to ensure the property that the program used only a limited set of semaphores.</p>
<p>Question: Where could I have checked for that property?</p>
<p>Well, the number of semaphores created would be proportional to the number of times <code>pipinit</code> was called, which I assumed was just once during system initialization. Turned out that <code>pipdelete</code> also called <code>pipinit</code>. As did my test setup function (when trying to reset all pipes).</p>
<p>Observation: It’s simple. I should have handled the case where <code>semcreate</code> returns SYSERR. That’s all. That’s how stupid my mistake was. Cost me a full hour spent scratching my head.</p>
<p><strong>Hypothesis</strong>: Bug -&gt; ask “which input configuration did I fail to handle?”.</p>
<p>Observation: This would never have happened in Haskell. It would have given me a <code>Maybe Semaphore</code>, whose <code>Nothing</code> case I would be forced to handle.</p>
<p>Lesson: In particular, look closely at the input type you’re getting.</p>
<p>For example, in <code>pipe_disconnect_writer</code>, instead of worrying about all the possible states that the rest of the system can be in, I should look at just the input pipe. It can be in a free, used, or connected state. If I handle all three cases faithfully, I’ve done my job. Nothing else to worry about.</p>
<p>Observation: The reader process could be in a waiting state when somebody disconnects it. So, I have to handle the different process states too.</p>
<p>Observation: I don’t know what to do in the various cases there.</p>
<h1 id="look-at-properties-of-your-own-input-not-of-other-functions">Look at Properties of your own Input, not of Other Functions</h1>
<p>Observation: Have to look at callers of <code>pipe_disconnect_writer</code> because I’m not sure if there can ever be a case where the reader disconnects first and leaves writer calling disconnect later.</p>
<p>Actually, I don’t have to. I can see that <code>pipe_disconnect_reader</code> always leaves writer disconnected. If the pipe to reader was in the PIPE_CONNECTED state, it would disconnect writer. Else, writer would have already been disconnected. Inference!</p>
<p>Hypothesis: I suspect I could avoid writer having to look through reader’s code by checking the invariants on pipe itself.</p>
<p>Pipe doesn’t even have a state for “reader disconnected but writer not yet disconnected”. That’s it. End of story.</p>
<p><strong>Hypothesis</strong>: A function shouldn’t need to look at the innards of other functions to decide what to do. It should just look at its inputs, their properties, and its own desired output properties.</p>
<h1 id="processing-evidence">Processing Evidence</h1>
<p>Question: What kinds of observations do I have to process?</p>
<p>For example, let’s consider each operation of the kind “ABCD -&gt; X and ABC’D’ -&gt; X implies that C and D probably don’t cause X” to be a single cognitive step. (I think we process that kind of stuff really quickly.)</p>
<p>Question: So, how many such operations do I have to run (for a given number of branches)?</p>
<h1 id="lost-track">Lost Track</h1>
<p>Observation: Got stuck debugging a stupid return value error. Lost track of what my original aim with.</p>
<p>One change at a time.</p>
<h1 id="debugging-principles">Debugging Principles</h1>
<p>Hypothesis: You need to have a really small test case.</p>
<p>My mistake with the scheduler was that I was working with a six processes all running at the same time doing god-knows-what. How are you supposed to debug that efficiently?</p>
<p>Observation: Not able to interpret the debugging output because there are too many printf statements and I don’t know what came from where.</p>
<p>Observation: Narrowed it down by toggling the high-level function calls. Things look much clearer. I know that the output is coming from a given two lines.</p>
<p>Observation: Narrowed it even further. Check only the semaphore part.</p>
<p>Observation: Right now, things “aren’t straight” in my head. I don’t know which configurations I’ve handled and which ones I haven’t. So, I don’t feel like I can reason about the behaviour of the program.</p>
<p><strong>Hypothesis</strong>: Know which inputs configurations you’ve handled and which not -&gt; feel confident about the behaviour of the program.</p>
<p><strong>Hypothesis</strong>: Notice what changes you’ve made. Any change in behaviour is due to a change you’ve made.</p>
<p>So, look at your diff from the previous state.</p>
<p><strong>Lesson</strong>: The moment you get an error, toggle back to a working state and then look at the differences.</p>
<h1 id="duplication-leads-to-more-input-configurations">Duplication Leads to More Input Configurations</h1>
<p>Observation: The official code had a state field that could take the value <code>PIPE_CONNECTED</code>, etc. However, that was strongly correlated with the writer and reader semaphore being free or not-free. So, I may have to consider multiple input configurations that actually mean the same thing.</p>
<p><strong>Hypothesis</strong>: Code duplication -&gt; more input configurations that give the same output but which you have to handle separately in case they are given inconsistently.</p>
<p>For example, I would have to flag an error in the case where the variable says <code>PIPE_CONNECTED</code> but the semaphores are actually free. Unnecessary headache.</p>
<p>Corollary: What’s more, when you finally merge those redundant input states, you’ll have to do a lot of careful work to remove the separate if-cases.</p>
<h1 id="truly-pure-functions">Truly Pure Functions</h1>
<p>Observation: Right now, some of my unit tests depend on more than one function. For example, testing disconnect depends on the correct behaviour of “connect”.</p>
<p>Hypothesis: Pure functions won’t be like that. You can genuinely test their input configurations alone.</p>
<p>Observation: But disconnect will still call pipe-related functions like reset or set writer or whatever.</p>
<p><strong>Hypothesis</strong>: Either your higher unit tests will test multiple functions or you will have to use equational reasoning.</p>
<h1 id="abstract-types-reduce-the-number-of-input-configurations">Abstract Types reduce the number of Input Configurations</h1>
<p>Question: How can we reduce the time taken to implement some features?</p>
<p>Observation: Time taken seems to depend on the number of test cases (aka input configurations) and the time taken to pass each test case.</p>
<p><strong>Hypothesis</strong>: Abstract types reduce the number of input configurations and thus reduce the number of tests.</p>
<p>For example, <code>sortInts :: [Int] -&gt; [Int]</code> has way more configurations than the generic <code>sort :: Ord a =&gt; [a] -&gt; [a]</code>.</p>
<p>Lesson: If you want to code faster, design your types well.</p>
<h1 id="understanding-knowing-the-output-for-each-input-configuration">Understanding = Knowing the Output for each Input Configuration</h1>
<p>Hypothesis: Understanding = knowing the output for each input configuration.</p>
<h1 id="confidence">Confidence</h1>
<p>Hypothesis: Confidence &lt;- knowing the possible input configurations and then knowing that you’ve handled all of them.</p>
<p>With my journal notes, for example, I don’t know the input configurations for some mechanism I’m trying to figure out (like how we learn) and so I don’t know if I’ve covered everything.</p>
<h1 id="assorted-ideas-todo">Assorted Ideas (TODO)</h1>
<p><strong>TODO</strong>: Composition (<code>pipe_is_writer_semaphore_free = pipe_is_semaphore_free . pipe_writer_semaphore</code>). Should you know the properties?</p>
<p>Duplication is bad because it makes you test essentially the same branch multiple times. For example, <code>pipe_is_writer_semaphore_free</code> and <code>pipe_is_reader_semaphore_free</code> both just call <code>pipe_writer_semaphore</code> with different arguments. But I have to run different tests.</p>
<p><strong>Hypothesis</strong>: When you have roughly the same test for two different functions, you have duplicated some code.</p>
<p>Hypothesis: If two branches give you the same output, merge them.</p>
<p>Hypothesis: Uncertainty &lt;- number of branches because the answer for each of those branches could be something different. You have to know all of the outcomes.</p>
<p>Hypothesis: Duplication -&gt; takes more work to test and more work to understand.</p>
<p><strong>Hypothesis</strong>: It’s a mistake to have duplicate code because you end up doing more work to test your program.</p>
<hr />
<p><strong>Hypothesis</strong>: In deliberate practice (and thinking in general), chunks correspond to the branches of your model.</p>
<p>So, chess grandmasters who have learned 50k chunks have learned 50k different branches of their model of chess.</p>
<p>Hypothesis: There’s a lot of duplication in there. You could probably merge parts of several branches. (Maybe it’s necessary for optimization - because they can recognize formations in a flash.)</p>
<p><strong>TODO</strong>: Figure out how you can represent each chunk - aka branch - as a flashcard, for easy learning.</p>
<h2 id="how-to-abstract">How to Abstract</h2>
<p>Hypothesis: Look at the input and output and merge those input configurations that have the same output. Also look at cases where the output part is a known function of the input.</p>
<h1 id="top-level-interventions-vs-surgical-interventions">Top-Level Interventions vs Surgical Interventions</h1>
<p>Observation: In the scheduler problem, I had to change one part of the system to affect the overall behaviour. In the pipes problem, however, I had full control of my system (since I was coding for the unit tests).</p>
<p>Question: Are they different in kind?</p>
<h1 id="when-there-are-no-readily-available-tests">When There are No Readily Available Tests</h1>
<p>Observation: Writing a research project proposal for a course - don’t know what is good and what isn’t.</p>
<p>Question: How do I get feedback? How do I go about implementing “code” (aka models) to handle different inputs?</p>
<p><strong>Hypothesis</strong>: Causes and effects all the way.</p>
<p>For example, come up with the causes and effects of surrogate endpoints.</p>
<h1 id="confused-write-a-test">Confused? Write a Test</h1>
<p>Observation: Confused about whether a process waiting on a semaphore will get a return value of SYSERR or OK. Been thinking about it for the last 10 minutes.</p>
<p>Hypothesis: Run a simple test to find out the answer.</p>
<p>Hypothesis: “Confused” = don’t know the output of some branch.</p>
<h1 id="make-a-change-only-when-a-test-fails">Make a Change only when a Test Fails</h1>
<p>Observation: Wasted a lot of time just staring at the screen hoping for a “perfect” solution to land in my mind.</p>
<p>Observation: I don’t have near-term tests for the changes I’m making to pipgetc. They are all abstract changes.</p>
<p>Observation: Long time since I ran <em>any</em> test (or even compiled the code). No feedback.</p>
<p><strong>Hypothesis</strong>: Make a change only when a test fails. Duh!</p>
<p>It’s called red-green-refactor. I’ve been making changes willy-nilly.</p>
<p>Corollary: Otherwise, you will end up making blue-sky changes to your code.</p>
<p>Corollary: Don’t have to think about abstract cases. Don’t have to “contemplate the ifs”. Just make the current test case pass.</p>
<p><strong>Hypothesis</strong>: Writing code without a failing test -&gt; don’t know if you’re cutting through.</p>
<p>Corollary: Writing to pass tests -&gt; consequentialism.</p>
<h1 id="interface-possible-input-configurations">Interface = Possible Input Configurations</h1>
<p>Hypothesis: Instead of talking about the “interface” to some program, talk about the different input configurations that it may receive. That, together with the expected output, defines its “interface”.</p>
<p>In other words, talk about the test cases it must satisfy.</p>
<p><strong>Corollary</strong>: Minimal interface = few input branches.</p>
<p>For example, <code>sort :: Ord a =&gt; [a] -&gt; [a]</code> has fewer possible inputs than <code>sortInts :: [Int] -&gt; [Int]</code>.</p>
<h1 id="minimizing-the-outputs">Minimizing the Outputs</h1>
<p>Observation: We’ve seen how to minimize the number of inputs to a function by combining those that produce the same output into the same category.</p>
<p><strong>Hypothesis</strong>: If you can get only a few possible outputs, forbid the other output values.</p>
<p>For example, a function that tells you whether or not a semaphore is free will return either true or false. Capturing that in an Int makes your interface unnecessarily large because the caller would have to assert that the output is either 0 or 1. So, make it a Bool.</p>
<h1 id="testing-a-high-level-function-shouldnt-be-blind">Testing a High-level Function: Shouldn’t be Blind?</h1>
<p>Question: Can you tell how many branches (and thus total test cases) a function will have, based on its type signature?</p>
<p><strong>Hypothesis</strong>: It depends on the definition.</p>
<p>For example, if I write <code>fourthRoot</code> from scratch, I would have to test several inputs cases like 0, 1, -1, 0.01, 4, etc. But if I know that <code>fourthRoot = sqrt &lt;=&lt; sqrt</code>, I feel like things become simpler.</p>
<p>Hypothesis: Number of test cases &lt;- amount of code duplication.</p>
<p>For example, <code>sortInts</code> and <code>sortLists</code> would share most of their code, except for the List- vs Int-handling parts. It would be stupid to test the same quicksort algorithm in both cases. <strong>Corollary</strong>: Amount of duplication among tests =&gt; amount of duplication among their functions. Question: So how would you do it ideally? How to not duplicate tests between <code>sortLists</code> and <code>sortInts</code>?</p>
<p>Hypothesis: The answer would seem to be to extract their common code into <code>sort</code>.</p>
<p>Then, you would write <code>sortLists = sort</code> (or just use sort directly where you would have used sortLists).</p>
<p><strong>Question</strong>: But say you did <code>fourthRoot = sqrt &lt;=&lt; sqrt</code>. What tests should you now write?</p>
<p>Hypothesis: You probably don’t need to check for invalid inputs like -1, etc. because sqrt already does that and returns <code>Nothing</code>.</p>
<p><strong>Corollary</strong>: A tester who insisted on being blind to the code and coming up with “advance predictions” would end up duplicating a ton of work for <code>fourthRoot</code>. Ditto for <code>sortLists</code> and <code>sortInts</code> if he didn’t understand that they used the same sorting algorithm.</p>
<p>Hypothesis: This is why people use type systems, so that they don’t have to duplicate their test code. They can reason about things from the types themselves.</p>
<h2 id="no-ifs-no-tests">No Ifs, No Tests</h2>
<p><strong>Hypothesis</strong>: You need to write unit tests only if you introduce new if-statements.</p>
<p>For example, take <code>f = uniq . sort</code>. Why do you believe that that function will return a sorted list unique elements?</p>
<p>Positive exemplar: When I wrote <code>pipgetc</code>, I had to test the cases where the function was supposed to return <code>SYSERR</code>. They were separate if-conditions in the code.</p>
<p>Hypothesis: Could it depend on the size of the function too?</p>
<p>Hypothesis: You should know the properties of each function in the chain.</p>
<p>For example, if I gave you <code>doSomeMagic . sort</code>, you wouldn’t really know what that function did.</p>
<p><strong>Observation</strong>: Ad hoc if-conditions in each function create exponential number of branches in a function chain.</p>
<p>In contrast, a return type of Maybe monadically composes to give you just two possible outputs at each point in the chain.</p>
<h2 id="when-can-you-chain">When can you Chain?</h2>
<p><strong>Hypothesis</strong>: You can chain together functions when each one “handles” all the possible outputs of the previous one.</p>
<p>For example, <code>uniq</code> handles the empty list and normal list outputs of <code>sort</code>. <code>sqrt</code> handles the Just and Nothing outputs of <code>sqrt</code>.</p>
<p>Corollary: Functions not in a chain -&gt; there could be output configurations you failed to handle.</p>
<p>For example, possible NULL values in C.</p>
<p>Observation: If I were doing pipe functions in a chain, I could be certain that they handled all the intermediate configurations. But since I was writing an imperative function, I didn’t know if I had handled the cases where the pipe became free after a call to wait or got disconnected or whatever.</p>
<h1 id="exams-input-branch-concept-needed">Exams: Input Branch = Concept Needed</h1>
<p>Hypothesis: Input branch = question that I have to answer. Which depends on the concepts needed.</p>
<p>Hypothesis: Input branch = concept needed. I need to have the correct output for each concept. Output = concept definition.</p>
<p>For example, I need to know what a “proper causal path” is, in case they ask for it in the exam.</p>
<h1 id="why-refactor-your-proofs-and-code">Why Refactor your Proofs and Code?</h1>
<p>Hypothesis: Refactor -&gt; find simple solution -&gt; store that as your output for that particular input.</p>
<p>Reuse that solution for other inputs -&gt; learn to recognize that input type based on this technique.</p>
<p>For example, HW2 8(c) took a lot of trial and error for me to find the answer. (Still don’t know if I’ve made a mistake somewhere.) Now, if I cleaned it up and got to the answer in, say, three steps, then I could extract general lessons from that clean solution.</p>
<p><strong>Observation</strong>: Basically, I’m unable to “draw lessons” from a jumble of trial-and-error proof steps.</p>
<p>Why not?</p>
<p><strong>Hypothesis</strong>: I can’t see which parts of the input led to which parts of the output.</p>
<p>So, my current “proof” (more like one page of arrows and scribbles) feels like it pertains only to problem 8(c). I can’t see what I would reuse for a variation of the problem.</p>
<p>Corollary: This is why you need to do proofs over and over till you get a succinct solution. (Ditto for programming.)</p>
<p><strong>Hypothesis</strong>: You need to bring your proof into a form where you can see that if you toggled a high-level variable A, you wouldn’t need to do step 1 anymore. If you toggled B, you wouldn’t need step 2 anymore, and so on.</p>
<p>Why can’t I do that now? The proof is so large and hairy that I can’t imagine the alternative.</p>
<h2 id="confused-by-the-options">Confused by the Options</h2>
<p>Observation: Still confused (even though I did the proof a few minutes ago).</p>
<p><strong>Hypothesis</strong>: Confusion = don’t know the conditions when you should choose option A vs option B vs option C.</p>
<p>For example, I can see that two back-door paths from X to Y are potentially unblocked if I condition on W1 or W2.</p>
<p>What options do I have? I could apply rule 2 on X, rule 3 on X, condition on Z1, condition on W2, condition on W1, or condition on some combination of those 3. Which one should I choose?</p>
<p>Next, if I choose to condition on Z, what should I do? Rule 2 on X, rule 3 on X, rule 2 or Z, rule 3 on Z, condition on W1, etc.</p>
<p>There are tons of options!</p>
<p>Observation: Experts somehow slice through this thicket of options and hone in on the correct one.</p>
<p><strong>Hypothesis</strong>: Given the graph and the desired expression, there is a direct way to come to the correct step <em>without</em> much trial and error.</p>
<p>Observation: There are only three trails from X to Y.</p>
<p>Hypothesis: Maybe there is a simpler way to come to an ID expression without traversing the do-calculus expression tree. Use the trails somehow.</p>
<h1 id="other-notes">Other Notes</h1>
<h2 id="types">Types</h2>
<p>Hypothesis: Ensure that your existing functions satisfy their exact interface (through type-checking and contracts and unit tests) and minimize their interface -&gt; don’t need to worry them anymore.</p>
<p>Hypothesis: One-button change &lt;- two things of the same type.</p>
<p>Hypothesis: Then, your actions would be: extend the current type, add an alternative of the same type, and minimize interface via type abstraction (and function abstraction if needed).</p>
<h2 id="alternatives-have-the-same-interface">Alternatives have the Same Interface</h2>
<p><strong>Hypothesis</strong>: Alternatives must have the same interface, or else you can’t switch between them without the user knowing the difference.</p>
<p>Question: Why, if at all, would this lead to functions with minimal interfaces?</p>
<p>Question: What would the overall code look like?</p>
<p><strong>Test</strong>: Try to reorganize an existing program like this, so you can compare the differences.</p>
<p>Hypothesis: At each point, the program will look like a hierarchical bunch of alternatives.</p>
<p>Hypothesis: Or, it will look like a bunch of overall alternatives.</p>
<h2 id="minimize-interface">Minimize Interface</h2>
<p>Question: Should you minimize interfaces during the refactor step?</p>

<div class="info">Created: October 20, 2017</div>
<div class="info">Last modified: October 25, 2017</div>
<div class="info">Status: in-progress notes</div>
<div class="info"><b>Tags</b>: notes, one-button</div>

<br />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'spkrationalitytrainingground'; // required: replace example with your forum shortname
    var disqus_identifier = '/one-button-change.html';
    var disqus_title = 'One-Button Change';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
	var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
