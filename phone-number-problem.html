<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/png" href="./images/favicon-32x32.png" sizes="32x32" />
	<link rel="icon" type="image/png" href="./images/favicon-16x16.png" sizes="16x16" />
        <title>The Phone Number Problem - SPK's Rationality Essays</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/highlight.css" />

	<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
	<!-- <script type="text/javascript" src="/js/header-links.js"></script> -->
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<link href="atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed" />

	<!-- Google Analytics stuff -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-51321929-1', 'pradeep90.github.io');
	  ga('send', 'pageview');

	</script>

    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Rationality Essays</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./notes.html">Notes</a>
                <!-- <a href="/about.html">About</a> -->
                <a href="./archive.html">Archive</a>
		<a href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
            </div>
        </div>

        <div id="content">
          <h1 id="post-title">The Phone Number Problem</h1>

            <!-- <center><img src="https://fbcdn-sphotos-d-a.akamaihd.net/hphotos-ak-prn1/t31.0-8/p600x600/10257116_10202295769100492_2438594605053717342_o.jpg" height="400" width="300" class="sujeet-pic" alt="Sujeet pic" /></center> -->

<p><strong>Note</strong>: This is a highly experimental essay.</p>
<h1 id="the-phone-number-problem">The Phone Number Problem</h1>
<p>Peter Norvig wrote about a problem that tried to compare Lisp as an <a href>alternative</a> to Java.</p>
<p>Having tried that problem, I think it’s a good way to test my ideas about program design.</p>
<h1 id="hypotheses">Hypotheses</h1>
<p><strong>Hypothesis</strong>: You can get to an ideal program design by seeking the minimum interface at each point of time. This will get you a program that gives you minimum uncertainty, maximum reusability, and least cost of change.</p>
<p>Question: Can your minimum-interface idea predict that solution given the problem? Try anyway and see where you come up short.</p>
<p><strong>Hypothesis</strong>: The program needn’t be as monolithic as it is now. All the constraints given in the problem seem to demand a large hairy function, but it may decompose to simple problems. Not everything needs to know about everything else.</p>
<p>Also, start backwards from the target. What comes before the final answer? <code>String &lt;- [(PhoneNumber, Encoding)] &lt;- ???</code>. What does one part of the encoding need to know about the others?</p>
<p>In short, figure out the overall type signature as well as the type signatures of the individual functions.</p>
<h2 id="minimum-interface">Minimum Interface</h2>
<p>How to get the “minimum interface” at each point? List all the things you do to get the answer.</p>
<p>Hypothesis: Identify the variables and functions, come up with a high-level program, and then let each function access only the variables it needs.</p>
<p>Also note the constraints on your functions. For example, the output of encode won’t have more than one consecutive EncodingDigit. I think you can consider these as properties that your functions must satisfy (or maybe unit tests).</p>
<p>Hypothesis: The problem statement gives you constraints. Some constraints you capture as properties (“<em>all</em> possible encodings”). Some you capture as types (“encoding should be possible from the dictionary” which translates as the type DictWord, which you can obtain only from a dictionary lookup).</p>
<p>So, it’s strong typing that gives you the benefit of types as constraints. It doesn’t let you coerce a String as DictWord even though that’s what a DictWord really is.</p>
<p>How to implement properties? Maybe implement the property test and then use that to implement the function. However, testing whether a property holds is a lot harder than implementing that property. How can you use information-processing to do that?</p>
<p>Perhaps the property involves an inefficient method of getting the result (why is it inefficient? how are you making it more efficient? are you solving a different problem?)</p>
<h2 id="minimize-the-interface">Minimize the Interface</h2>
<p>First get the ideal solution and then figure out how to get to it from the problem statement.</p>
<p><strong>TODO</strong>: Refactor - Test your Hindley-Milner idea by running the algorithm over the code and figuring out the maximally-decoupled program.</p>
<p><strong>Hypothesis</strong>: Minimizing the information needed works to get you the <strong>causal structure</strong> - you figure out which variables you don’t need for a particular function. After that, you have to use a causal model - a <strong>function</strong> - to decide how to get a from b.</p>
<p><strong>TODO</strong>: Seek the minimum interface at each point. This is while designing the program.</p>
<h1 id="trial-1">Trial 1</h1>
<p>From http://www.flownet.com/ron/papers/lisp-java/instructions.html</p>
<blockquote>
<p>Functional requirements</p>
<p>Your task is writing a program that finds, for a given phone number, all possible encodings by words, and prints them. A phone number is an arbitrary(!) string of dashes - , slashes / and digits. The dashes and slashes will not be encoded. The words are taken from a dictionary which is given as an alphabetically sorted ASCII file (one word per line).</p>
</blockquote>
<p>Variables: phone number, encodings, words, encodings by words, dictionary</p>
<p>Functions: print all encodings, encoding from phone number, words from dictionary</p>
<p>Property: encode must return “all possible” encodings</p>
<blockquote>
<p>[NOTE: The dictionary is in German and contains umlaut characters encoded as double-quotes. The double-quotes should be ignored. EG.]</p>
</blockquote>
<p>Variables: words with double-quotes, words without double-quotes</p>
<p>Functions: words without double-quotes &lt;-&gt; words with double-quotes</p>
<blockquote>
<p>Only exactly each encoding that is possible from this dictionary and that matches the phone number exactly shall be printed. Thus, possibly nothing is printed at all. The words in the dictionary contain letters (capital or small, but the difference is ignored in the sorting), dashes - and double quotes &quot; . For the encoding only the letters are used, but the words must be printed in exactly the form given in the dictionary.</p>
</blockquote>
<p>Variables:</p>
<p>Functions: encoding is possible from dictionary, encoding matches phone number exactly, print word in the form given in the dictionary</p>
<p>Property: encode - the encoding must match the phone number exactly (as per matches)</p>
<blockquote>
<p>Leading non-letters do not occur in the dictionary.</p>
</blockquote>
<p>Variables:</p>
<p>Functions:</p>
<p>Property: leading non-letters do not occur in the dictionary.</p>
<blockquote>
<p>Encodings of phone numbers can consist of a single word or of multiple words separated by spaces. The encodings are built word by word from left to right. If and only if at a particular point no word at all from the dictionary can be inserted, a single digit from the phone number can be copied to the encoding instead. Two subsequent digits are never allowed, though. To put it differently: In a partial encoding that currently covers k digits, digit k+1 is encoded by itself if and only if, first, digit k was not encoded by a digit and, second, there is no word in the dictionary that can be used in the encoding starting at digit k+1.</p>
</blockquote>
<p>Variables: single word or multiple words separated by spaces; words from left to right;</p>
<p>Functions: when can a digit be copied; partial encoding?</p>
<p>Property: encodings are non-empty;</p>
<p>Insert digit only if no word can be inserted (prefix + no word =&gt; prefix + digit). This is a stateful property. You can’t test it with just PhoneNumber, Encoding -&gt; Bool because that “4824: 4 Ort, because in place of the first digit the words Torf, fort, Tor could be used”. This implies that the encode function has to track the state too.</p>
<p>No consecutive digits</p>
<blockquote>
<p>Your program must work on a series of phone numbers; for each encoding that it finds, it must print the phone number followed by a colon, a single(!) space, and the encoding on one line; trailing spaces are not allowed. All remaining ambiguities in this specification will be resolved by the following example. (Still remaining ambiguities are intended degrees of freedom.)</p>
</blockquote>
<p>Variables: series of phone numbers</p>
<p>Functions: print phone number and one encoding;</p>
<h2 id="high-level-specification">High-level Specification</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">dictionary ::</span> <span class="dt">Dictionary</span>

<span class="ot">phoneNumbers ::</span> [<span class="dt">PhoneNumber</span>]

<span class="ot">encode ::</span> <span class="dt">Dictionary</span>, <span class="dt">PhoneNumber</span> <span class="ot">-&gt;</span> [<span class="dt">Encoding</span>]

<span class="ot">printEncodingWithPhoneNumber ::</span> (<span class="dt">PhoneNumber</span>, <span class="dt">Encoding</span>) <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">cleanWord ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">originalWord ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>

main <span class="fu">=</span> unlines <span class="fu">.</span> map printEncodingWithPhoneNumber <span class="fu">.</span> concatMap (\p <span class="ot">-&gt;</span> map ((,) p) <span class="fu">.</span> encode dictionary <span class="fu">$</span> p) <span class="fu">$</span> phoneNumbers</code></pre></div>
<h2 id="use-an-abstract-type">Use an Abstract Type</h2>
<p>Try to minimize the information you get. For example, instead of saying that <code>Encoding :: String</code>, which would make you think you can get it from <code>PhoneNumber</code> via <code>digitToLetterMap</code>, say that <code>Encoding :: [DictWord | Digit]</code> and that <code>newtype Dictionary = [DictWord]</code>. That way you can’t cheat - the only way to get an <code>Encoding</code> from a <code>PhoneNumber</code> is by going through <code>Dictionary</code>.</p>
<p>One way to minimize the information you get is by replacing the concrete types by an abstract type. For example, replace every (consistent) mention of Int with a newtype <code>PhoneNumberDigit</code> or whatever. Not only does this make your code more reusable, it also makes it simpler and easier to understand (not sure of this).</p>
<p>Moreover (and I didn’t really suspect this before now), it makes it explicit which values depend on which other values. When you’re given <code>encode :: PhoneNumber a -&gt; [Encoding c]</code> and <code>digitToLetterMap :: a -&gt; [b]</code> and <code>lookupWord :: [b] -&gt; Maybe [c]</code>, it’s pretty obvious that you cannot write (a useful version of) <code>encode</code> without using <code>digitToLetterMap</code> and <code>lookupWord</code>. Whereas when you’re given <code>encode' :: [Char] -&gt; [ [Char]]</code> and <code>digitToLetterMap' :: Char -&gt; [Char]</code> and <code>lookupWord' :: [Char] -&gt; Maybe [Char]</code>, you could write a dozen versions of <code>encode</code> without ever touching <code>digitToLetterMap'</code> or <code>lookupWord'</code>.</p>
<p>How can we know when two types should use the same type variable? Use different type variables for everything initially and then unify them only when needed.</p>
<p>(<strong>Note</strong>: The above examples don’t actually make my point. The type variables a and b in <code>digitToLetterMap :: a -&gt; [b]</code> could just as well be a and c, so you can use the function to implement encode. What I really need is different types like <code>digitToLetterMap :: PhoneDigit -&gt; [PhoneLetter]</code> such that you can’t intermix <code>PhoneLetter</code>s and <code>Char</code>s. However, that makes the code hard to reuse.)</p>
<p>(<strong>TODO</strong>: Use <code>newtype PhoneNumber = PhoneNumber String</code>. Test it in a few simple programs and see how annoying it is.)</p>
<p>Suddenly, you know practically nothing about the type. Literally the only thing you can do with a <code>PhoneNumberDigit</code> is call <code>lookup</code> on it. How’s that for a no-brainer? It turns your bushy search tree into a short, sparse graph (I think).</p>
<h2 id="how-to-minimize-work-needed">How To Minimize Work Needed?</h2>
<p><strong>Hypothesis H1</strong>: Use type variables like a and b. I don’t know exactly how because you could just as well use any type instead of a type variable a.</p>
<p><strong>Hypothesis H2</strong>: Use newtypes like PhoneNumber. But that seems to reduce reusability.</p>
<p><strong>Hypothesis H3</strong>: Use building blocks of a certain granularity beneath which you won’t look. For example, don’t use Chars, use PhoneDigits. That way you minimize your total uncertainty. Anybody can produce any Char, thus you have a lot of uncertainty about it. However, there are very few ways to produce PhoneDigits or DictWords, so you’re less uncertain.</p>
<p>Given the input PhoneNumber, you would know of very few paths to get a DictWord.</p>
<h2 id="use-newtypes">Use newtypes</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">dictionary ::</span> <span class="dt">Dictionary</span>

<span class="ot">digitToLetterMap ::</span> <span class="dt">PhoneDigit</span> <span class="ot">-&gt;</span> [<span class="dt">DictLetter</span>]

<span class="ot">lookupWord ::</span> [<span class="dt">DictLetter</span>] <span class="ot">-&gt;</span> <span class="dt">DictWord</span>

<span class="ot">phoneNumbers ::</span> [<span class="dt">PhoneNumber</span>]

<span class="ot">phoneNumber ::</span> [<span class="dt">PhoneDigit</span>]

<span class="dt">Encoding</span> <span class="fu">=</span> <span class="dt">EncodingWord</span> <span class="fu">|</span> <span class="dt">EncodingDigit</span>

<span class="ot">encodingDigit ::</span> <span class="dt">PhoneDigit</span> <span class="ot">-&gt;</span> <span class="dt">EncodingDigit</span>

<span class="ot">encode ::</span> <span class="dt">Dictionary</span>, <span class="dt">PhoneNumber</span> <span class="ot">-&gt;</span> [<span class="dt">Encoding</span>]

<span class="ot">printEncodingWithPhoneNumber ::</span> (<span class="dt">PhoneNumber</span>, <span class="dt">Encoding</span>) <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="ot">cleanWord ::</span> <span class="dt">DictWord</span> <span class="ot">-&gt;</span> <span class="dt">EncodingWord</span>

<span class="ot">originalWord ::</span> <span class="dt">EncodingWord</span> <span class="ot">-&gt;</span> <span class="dt">DictWord</span>

main <span class="fu">=</span> unlines <span class="fu">.</span> map printEncodingWithPhoneNumber <span class="fu">.</span> concatMap (\p <span class="ot">-&gt;</span> map ((,) p) <span class="fu">.</span> encode dictionary <span class="fu">$</span> p) <span class="fu">$</span> phoneNumbers</code></pre></div>
<h2 id="properties">Properties</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_nonEmptyEncoding ::</span> <span class="dt">Encoding</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">prop_matches ::</span> <span class="dt">PhoneNumber</span>, <span class="dt">Encoding</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">prop_partialMatches ::</span> <span class="dt">Encoding</span>, <span class="dt">PhoneNumber</span>, <span class="dt">Encoding</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">prop_allPossibleEncodings ::</span> digitToLetterMap, <span class="dt">Dictionary</span>, <span class="dt">PhoneNumber</span>, [<span class="dt">Encoding</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">prop_noConsecutiveDigits ::</span> <span class="dt">Encoding</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<h2 id="implement-encode">Implement encode</h2>
<p>Each encoding is independent of the other encodings given the dictionary and phone number. However, its position in the list depend on our implementation.</p>
<pre><code>encode :: Dictionary, [PhoneDigit] -&gt; [Encoding]</code></pre>
<p>What can we <em>possibly</em> do with the inputs to get the output? What functions involve Dictionary, PhoneDigit, or Encoding as arguments?</p>
<p>Work backward from the output. What gives Encoding as an output? Only EncodingWord or EncodingDigit. What gives them as outputs? Only cleanWord gives EncodingWord and only encodingDigit gives EncodingDigit.</p>
<h3 id="encodingdigit">EncodingDigit</h3>
<p>encodingDigit :: PhoneDigit -&gt; EncodingDigit</p>
<p>So, one possible option is to map encodingDigit over the input [PhoneDigit] or do it for the first digit and repeat the answer or several other options.</p>
<h3 id="encodingword">EncodingWord</h3>
<p>TODO</p>
<h3 id="encode">Encode</h3>
<p>Define it recursively! Assume you have a function (<code>:: Dictionary, [PhoneDigit] -&gt; [Encoding]</code>).</p>
<p>Divide the input into smaller inputs and then combine your outputs for them. Basically, the first parts of each Encoding depend only on prefixes of the phone number. More specifically, the first token of each Encoding is independent of the rest given a prefix. How would you know that? Because <code>map (lookupWord . map dictLetter) . traverse digitToLetterMap</code> on <code>[PhoneDigit]</code> gives you DictWords from which you can get EncodingWords. So, you can try that on the whole phone number, but you can also try that on a subset (or rather, prefix) of it. The question is which prefix you should take. Try all of them. The first token of each encoding in the set of all possible encodings will have a corresponding prefix in the phone number.</p>
<p>That is, the first token of each encoding in the set of all possible encodings is <strong>caused</strong> by a prefix of the phone number. There’s a one-to-many function from the prefix to the first tokens of the possible encodings. Note that the first token is not caused by a permutation of the digits of the phone number or some other thing. It’s caused by a simple prefix.</p>
<h2 id="all-possible-encodings">All possible encodings</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prop_allPossibleEncodings ::</span> digitToLetterMap, <span class="dt">Dictionary</span>, <span class="dt">PhoneNumber</span>, [<span class="dt">Encoding</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_allPossibleEncodings dlMap d p es <span class="fu">=</span> es <span class="fu">==</span> undefined</code></pre></div>
<p>What would be an inefficient way of doing it?</p>
<p>One way is to generate all possible PhoneWords (including some digits), generate splits, and look them up in the dictionary.</p>
<p>Another way is to combine dictionary words and use letterToDigitMap to see if they match the phone number.</p>
<p>Why is this inefficient?</p>
<h1 id="research-conclusions">Research Conclusions</h1>
<p>If I couldn’t figure out a first-principles method to solve the phone number problem, it means my hypothesis was wrong. It isn’t all categories and causal models.</p>
<h1 id="future-plan">Future Plan</h1>
<p>Instead of trying to invent a “programming algorithm” from first principles, why not analyze real-world problems and solutions to see how to improve your existing approach? See where you got stuck on the phone number problem and figure out how you could have got it right the first time around.</p>
<p>One example of such a technique is your “if it fails, get back to adding one piece at a time” idea. You’ve faced that problem several times and this method will help in the future.</p>

<div class="info">Created: February 23, 2017</div>
<div class="info">Last modified: February 28, 2017</div>
<div class="info">Status: in-progress notes</div>
<div class="info"><b>Tags</b>: notes, metacognitive, programming</div>

<br />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'spkrationalitytrainingground'; // required: replace example with your forum shortname
    var disqus_identifier = '/phone-number-problem.html';
    var disqus_title = 'The Phone Number Problem';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
	var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
