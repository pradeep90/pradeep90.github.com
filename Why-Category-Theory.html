<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/png" href="./images/favicon-32x32.png" sizes="32x32" />
	<link rel="icon" type="image/png" href="./images/favicon-16x16.png" sizes="16x16" />
        <title>Why Category Theory - SPK's Rationality Essays</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/highlight.css" />

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
	<script type="text/javascript" src="./js/header-links.js"></script>

	<!-- Google Analytics stuff -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-51321929-1', 'pradeep90.github.io');
	  ga('send', 'pageview');

	</script>

    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Rationality Essays</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./sequences.html">Sequences</a>
                <!-- <a href="/about.html">About</a> -->
                <a href="./archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
          <h1 id="post-title">Why Category Theory</h1>

            <!-- <center><img src="https://fbcdn-sphotos-d-a.akamaihd.net/hphotos-ak-prn1/t31.0-8/p600x600/10257116_10202295769100492_2438594605053717342_o.jpg" height="400" width="300" class="sujeet-pic" alt="Sujeet pic" /></center> -->

<p><strong>Entry Question</strong>: Why do I plan to learn more of Category Theory?</p>
<hr />
<h1 id="whats-the-big-deal">What’s the big deal?</h1>
<p>As we saw, the newest Big Problem on the block seems to be Complexity - aka finding out the truth when there is a ton of information involved. It seems that our normal truth-finding methods like Bayes Theorem and hypothesis testing don’t scale to such levels.</p>
<p>Why not? Cos the hypotheses (aka programs) become very large. It’s harder to do controlled experiments. Psychology is a prime example. While you can do precise experiments in Physics, you can’t even run simple experiments in Psychology. You’re trying to model the human mind and that shit is <strong>software</strong> - orders of magnitude more complex than hardware (as mentioned by Frederick Brooks in his classic No Silver Bullet paper).</p>
<p>In fact, programming is exhibit number one when it comes to solving very complex problems. The sort of problems that programmers have to deal with everyday are problems of complexity. That’s why it’s much harder to get high-quality software.</p>
<p>I’ve often wondered - why don’t programmers use the Scientific Method more? I mean, the Scientific Method rocks right? It rules so many other fields of knowledge, why not here? Won’t you develop programs much faster with higher guarantees of correctness if you develop it scientifically?</p>
<p>Well, it doesn’t work out that way. There are too many things going on for you to be able to use naive Scientific Method directly.</p>
<p>But programmers do get the job done well enough. How come? They just use far more sophisticated techniques that (sort of) scale to the level of problem.</p>
<p>And you can’t accuse programmers of being wishy-washy or imprecise in their theories (like you accuse psychologists), or say that their models don’t actually describe reality (like you accuse macroeconomists). Why not? Cos programmers are held to a much stricter standard than any of those people. Programming is a fundamentally consequentialist affair (?). You have to get things to work. You cannot build a program half-way and give up saying that you’ve done enough. It must work in the end or your efforts were for nought.</p>
<p>In programming, it isn’t other people who judge your work, it is the computer. Your program doesn’t merely have to <em>sound</em> plausible to the human mind, it must fall within the narrow gap of programs that will actually execute to give the results you want. The computer is like nature - unmoved by your eloquent pleas. If you get it wrong, it will simply reject your program (and possibly make bad things happen).</p>
<p>Programmers have to produce results. They have to Win. And if that isn’t the definition of Rationality, I don’t know what is.</p>
<p>Remember, you’re not beholden to the Scientific Method or anything like that. The reason you like the Scientific Method (or Bayes Theorem) is because it gets you results.</p>
<p>[The Way of the Ichi School quote]</p>
<p>Funnily enough, programmers <em>are</em> using Bayes Theorem implicitly. You have to if you want to get to the truth - it is highly improbable that you will come up with the right answer out of thin air. Your information-processing <a href>engine</a> - your mind - has to consume evidence if it wants to get the right answers.</p>
<p>Evidence doesn’t have to come from scientists wearing white lab coats in some research facility. It doesn’t have to come from a formal Hypothesis-Experiment-Results-Cardboard-Poster process (a la Hermione). You don’t even need to hold Bayes Theorem in your mind for it to work. All you have to do is listen to reality.</p>
<p>Well, for programmers, reality (the computer) is shouting in their ear. Things don’t just quietly fail. They blow up! It is <em>hard</em> to avoid listening to the evidence. You will go out of business as a programmer if you do.</p>
<h1 id="programs-as-hypotheses">Programs as Hypotheses</h1>
<p>Here’s my model: for programmers, their program <strong>is</strong> their hypothesis about the solution. And how do they run “hypothesis tests”? They just run their program on various tests.</p>
<p>Most often, the tests are part of the problem requirements. Or, in advanced languages, you have some property or contract that your function must fulfill. So, you need to work your hypothesis - your program - till it passes all those tests.</p>
<p>So, yes, programming is heavily backed by evidence. You could even argue that they take in more evidence than any other field. They have to - the solution really is that complex and if you need to build your hypothesis to match the truth fully, you need to process at least a proportionate amount of evidence.</p>
<p>As we have <a href>seen before</a>, the complexity of a hypothesis is basically the length of the program that represents that hypothesis.</p>
<p>Here, the hypothesis is directly represented as a program. So, the complexity of some programming problem is measured by the length of the program you have to write to solve it.</p>
<p>(???) What about the time it takes you to write that program? Couldn’t that differ? For example, an algorithm might come down to a few lines of code, but discovering that algorithm takes a lot of time.</p>
<p>Also, there is Accidental Complexity to account for. Some languages give you shit abstractions so you can’t really express your hypothesis cleanly. You’re forced to add more lines of code to say one thing.</p>
<p>For now, we can assume that you’re coding in the most powerful language you can find, so that your abstractions are kind of keeping up with your mind.</p>
<h1 id="changing-requirements">Changing requirements</h1>
<p>If programming to some requirements were all, then programming might be a bit more tractable. But, the requirements don’t stay fixed. They change rapidly. In most cases, the requirements aren’t even clearly specified. It’s part of your job to discover them. You do this by trying out different things and seeing what sort of things your users want.</p>
<h1 id="why-category-theory-then">Why Category Theory, then?</h1>
<p>Looks like programmers have got it handled. What more do you want?</p>
<p>Not so fast. Programming is a mess right now.</p>
<p>We need better means of abstractions. We need better means of composition.</p>
<p>I have a feeling that Category Theory will help out here.</p>
<p>How precisely?</p>
<h1 id="compositional-programming">Compositional Programming</h1>
<p>The promising thing about Category Theory is that it can allow you to compose an insane number of things.</p>
<p>I’ll use Haskell in my examples.</p>
<p>You can obviously compose functions to get functions. (a -&gt; b) and (b -&gt; c) will give you (a -&gt; c).</p>
<p>Assume <code>square</code> is of type (Int -&gt; Int) and <code>cube</code> is of type (Int -&gt; Int), then you can write:</p>
<pre><code>power6 = cube . square</code></pre>
<p>Neat and simple. Couldn’t have put it better. The “.” there is the compose operator. It put square and cube together to get a new function.</p>
<p>Similarly, (a -&gt; b) and (b -&gt; c) and … (y -&gt; z) give you (a -&gt; z).</p>
<p>Well, if your program is purely functional - aka no side effects - then you have effectively brought down the complexity by 1/n. You can now reason about that whole sequence of functions as just one function. As Forrest Gump would say, N less things to worry about.</p>
<p>If our ability to solve problems is strictly limited by our information-manipulation capabilities, then anything that reduces the amount of information you need to manipulate to solve a problem is awesome. Function composition is right up there.</p>
<p>Of course, there are conditions on which functions you can compose. They have to share the same type - you can compose (a -&gt; b) and (b -&gt; c), but not (a -&gt; h) and (x -&gt; m).</p>
<p>Cool. Accepted. There are limits.</p>
<h1 id="not-just-composable-functions">Not just composable functions</h1>
<p>What else can you compose?</p>
<p>Say you have a function <code>children</code> of type (Human -&gt; [Human])?</p>
<p>How will you write a function that gives a person’s grandchildren? You have to go through all kinds of trouble just to say what you would have said in three words in English - children of children.</p>
<p>Even in a good functional language like Scheme, you would have to say:</p>
<pre><code>(define grandchildren (x)
	(concat (map children (children x))))</code></pre>
<p>That map in there is basically looping over the list of children and getting their children and the concat is putting them all together.</p>
<p>What about great-grandchildren, you ask? Children of children of children, right?</p>
<pre><code>(define great-grandchildren (x)
	(concat (map children (concat (map children (children x))))))</code></pre>
<p>or, if you cheat and use grandchildren:</p>
<pre><code>(define great-grandchildren (x)
	(concat (map children (great-grandchildren x))))</code></pre>
<p>We desperately want to say grandchildren are just children of children, but Scheme is not letting us. Can’t we compose children with children? Nope. The types don’t match. <code>children</code> takes a Human and returns a <strong>list</strong> of Humans, so you can’t pass that on to <code>children</code>.</p>
<p>Monads to the rescue.</p>
<pre><code>grandChildren = children &lt;=&lt; children

greatGrandChildren = children &lt;=&lt; children &lt;=&lt; children</code></pre>
<p>What do you say about that!</p>
<p>You can see the similarity to function composition. Just like we used “.” to put square and cube together, we’re using “&lt;=&lt;” here to put children and children together.</p>
<p>The <code>.</code> operator is the way to compose functions that share the same output and input type (respectively).</p>
<p>The <code>&lt;=&lt;</code> operator is the way to compose functions that share almost the same output and input type - just that for one, the output is wrapped in some form.</p>
<p>We call these monadic functions. For <code>children</code>, the output was wrapped in a list (<code>[Human]</code>).</p>
<p>We can pull the same trick with lots of functions with lots of different kinds of wrappings.</p>
<p>(Note: I’m being loose in my descriptions here. Just use the “wrapping” analogy as a jumping board for now.)</p>
<p>For example, you have a function that usually works but may fail for some input. Like, say, <code>sqrt</code>. It takes an Int and returns another Int, but will fail on negative input. So, we represent that output as a Maybe Int - it can either be Just Int (sqrt 16 = Just 4) or it can be Nothing (sqrt -3924 = Nothing). Nothing is basically our <code>null</code>.</p>
<pre><code>sqrt :: (Int -&gt; Maybe Int)</code></pre>
<p>How can we write safe code using sqrt? For example, how would you write x^(1/4) using sqrt? In (pseudo) Java:</p>
<pre><code>Integer fourthRoot(Integer x) {
	// sqrt assumes that its input is non-null.
	if (x == null)
		return null;
	Integer y = sqrt(x);
	if (y == null)
		return null
	return sqrt(y);
}</code></pre>
<p>But, x^(1/4) is just sqrt of sqrt. We don’t want to do all that unnecessary null-checking. If anything is null along the way, the whole answer is null. Obvious! Why make me write it out by hand every time?</p>
<pre><code>fourthRoot = sqrt &lt;=&lt; sqrt</code></pre>
<p>Here, <code>&lt;=&lt;</code> let us compose two functions of (Int -&gt; Maybe Int) to get a new function of (Int -&gt; Maybe Int).</p>
<p>Similarly, if you wanted to find some integer in a list and then take its square root. <code>find</code> can fail too (there may not be any matching element in the list). So, simplifying a bit, it’s type is ([Int] -&gt; Maybe Int).</p>
<p>This means we can’t compose sqrt and find. If they could never fail then we could just do <code>sqrt . find</code>. Done. Do find first and then do sqrt on what you find. Piece of cake. But, nope. They can fail so their types aren’t compatible for function composition.</p>
<pre><code>Integer findAndSqrt(List&lt;Integer&gt; xs) {
	// findSomeElem expects non-null input.
	if (xs == null)
		return null;
	Integer y = findSomeElem(xs);
	if (y == null) {
		return null;
	}
	return sqrt(y);
}</code></pre>
<p>Again that nasty null-checking. No more.</p>
<pre><code>findAndSqrt = sqrt &lt;=&lt; findSomeElem</code></pre>
<p>We can scale this up to an arbitrary number of functions.</p>
<pre><code>doComplicatedProcessing = getAge &lt;=&lt; getFatherDetails &lt;=&lt; lookupPersonIdInDatabase &lt;=&lt; findMatchingId</code></pre>
<p>Each of those functions could return null. But, at no point did we have to stop thinking about our logic and go do some stupid null-checking. <code>&lt;=&lt;</code> let us do our job and just let us compose potentially failing functions elegantly.</p>
<p>There are tons of other applications for <code>&lt;=&lt;</code>. Anywhere you have functions that return “wrapped” values and you want to compose them, you can <code>&lt;=&lt;</code>.</p>
<p>Just like with normal function composition, we were able to put together a whole bunch of functions into one final function and do it with ease.</p>
<p>Ok. So we can compose normal functions, and we can compose wrapping functions (<a href>monadic</a> functions, in other words). Is that all?</p>
<h1 id="composing-objects">Composing Objects</h1>
<p>Let’s look at list concatenation. <code>l1 ++ l2</code> means appending l2 to l1.</p>
<pre><code>[1, 2] ++ [3, 4, 5] = [1, 2, 3, 4, 5]

[1, 2] ++ [3, 4, 5] ++ [6, 7] = [1, 2, 3, 4, 5, 6, 7]

= ([1, 2] ++ [3, 4, 5]) ++ [6, 7]

= [1, 2] ++ ([3, 4, 5] ++ [6, 7])</code></pre>
<p>All that to say that list concatenation is associative. The order in which you do those individual concatenations doesn’t change the result. Big deal. Right?</p>
<p>Also, the empty list concatenated to the left or right of any list just gives the same list back. Yo, that’s just another way of saying that <code>++</code> has a left and right identity.</p>
<p>Breaking news. So what?</p>
<p>The point is that even after putting together a lot of lists, you get one list in the end. You don’t have to worry about all the individual details. Put them together and now you’ve got one list to represent them all. You can even put this list together with other lists and still get a list back.</p>
<p>The complexity doesn’t rise up as you put together many lists. It says absolutely flat throughout.</p>
<p>The above properties don’t just hold for lists and strings. They hold for numbers too, under addition and multiplication.</p>
<p>They hold for functions that have the same input and output type. Gabriel gives the example of Plugins. You can think of a plugin for some application to be of type (Request -&gt; Data). It takes some request and returns the desired data.</p>
<hr />
<p>(This is my own example. There could be mistakes in my understanding here.)</p>
<p>Say you’re writing a search aggregator for some company. The idea is that employees will enter a phrase and you will bring in search results from the different parts of that company - say HR, manufacturing, marketing, whatever. All of these parts have their own customized search facility - manufacturing lets you search within their orders, marketing lets you search within their records, whatever. You need to bring all of that to one interface in front of the user.</p>
<p>At first, you decide to support searching just one department - the Software Engineering department. Easier to test your aggregator with just one search backend.</p>
<p>You write a function getSWEnggSearchResult of type (Search -&gt; SearchResult). The SearchResult is some properly-formatted thing that you can display directly. You don’t need to know what is inside it. It has a “convertToHTML” method, so to speak, and you can just use that.</p>
<p>Cool. It works! All your hours of coding and debugging have paid off. Ok. Now, you need to add more backends.</p>
<p>You decide to add one more - HR Department. So, you write a function getHRSearchResult of type (Search -&gt; SearchResult). And, in your main function, you first call getSWEnggSearchResult and insert its HTML output into your page. Then, you call getHRSearchResult and insert its HTML output into your page.</p>
<p>That works too! Then, you go ahead and do this for every single other goddamn department in your company. The main function balloons up with all kinds of getFooSearchResults.</p>
<p>Then, next month, the company merges with another company. You get 10 more departments whose search backends you have to support. Then, at the end of the year, that company is sold off to some other company - so you now need to split off your application into two - one that supports your company’s backends and one that supports theirs. You hand that over to them. And, so it goes on.</p>
<hr />
<p>What could you have done differently?</p>
<p>You say that the type of Backend is (Search -&gt; SearchResult). If SearchResult is a Monoid (which it seems to be), then (Search -&gt; SearchResult) will automatically be a Monoid. We can easily compose all these Backends together.</p>
<p>I will use the <code>&lt;&gt;</code> sign to show appending of two Monoids.</p>
<p>We will call it SWEnggBackend instead of getSWEnggSearchResult.</p>
<p>So, initially:</p>
<pre><code>backend = SWEnggBackend</code></pre>
<p>Then, you added the HR backend.</p>
<pre><code>backend = SWEnggBackend &lt;&gt; HRBackend</code></pre>
<p>What this does is create a <strong>composite function</strong> that takes a Search and passes it to both the backends. It then takes the results and appends them together (because SearchResult is a Monoid).</p>
<p>This means that from the point of view of the program, there is only <strong>one</strong> backend. You can add as many as you want, it will all look just like one backend, a simple Monoid of type (Search -&gt; SearchResult). This will hold up even when the company merges with another.</p>
<pre><code>ourBackend = SWEnggBackend &lt;&gt; HRBackend &lt;&gt; ...

theirBackend = FooBackend &lt;&gt; BarBackend &lt;&gt; ...

backend = ourBackend &lt;&gt; theirBackend</code></pre>
<p>No part of your program has to change with all the other changes. You don’t have to add the complexity of having a list of backends and then processing them manually. In fact, each of those backends could themselves encompass several other backends about which you need know nothing.</p>
<p>To your program, there is just one backend. At each point, you’re dealing with just <strong>one</strong> composite backend. The code complexity of your program stays constant no matter how many backends you add.</p>
<hr />
<h1 id="what-has-this-got-to-do-with-real-life-problems">What has this got to do with real-life problems?</h1>
<p>I think problem-solving in real-life is just like programming. It merely works in a different language than normal programming. There are different primitives here.</p>
<p>But, I think the lessons of programming can transfer here.</p>
<h1 id="resolving-confusion">Resolving Confusion</h1>
<p>For the past two weeks, I’ve been trying to get a better grasp of the concepts in Category Theory, but to no avail. The only time I really <em>got</em> some ideas in there was when somebody explained them in terms of programming concepts. Otherwise, it really was all sounding like abstract nonsense.</p>
<p>More precisely, it sounded like a whole bunch of work that had no practical value for me. I couldn’t see how it would apply to my life and how it would make my life better. So, I couldn’t put in the effort needed to understand them. I mean, why? Why learn about limits, co-limits, pullbacks, adjuncts, whatever? How is it gonna help me?</p>
<p>Well, I suspect that they do have benefits for me. I just don’t know it yet. The point is all the benefits of Category Theory so far have been in high-flying mathematics or physics - all involving abstruse stuff like topology and stuff.</p>
<p>The problem is that because all the topics that Category Theory has been applied to have been advanced math topics, I started thinking that it would take a much more advanced mind than mine to understand Category Theory.</p>
<p>I started thinking of Category Theory as <em>deeply confusing</em>.</p>
<p><strong>Warning!</strong></p>
<p>Things aren’t confusing or non-confusing in themselves. It is we who are confused by them.</p>
<p>I need to look at Category Theory as just another ordinary bunch of ideas that can potentially help me out a lot. Nothing more, nothing less. I’m getting needlessly intimidated and confused (the inaccessible books don’t help either).</p>
<p>I need to cut through this web of confusion and see the concepts as they are. I need to see the various events that I’m interested in and what Category Theory says about those events (aka, what predictions it makes). In the end, that’s all that matters - the Predictive Power that Category Theory gives me.</p>
<h1 id="what-needs-to-be-done">What needs to be… done?</h1>
<p>Collect the most challenging problems you know of, the ones that you think involve the most complexity, i.e., the ones for which you think you will need to get a lot of evidence before you can hit upon the correct solution.</p>
<p>Then, try to reduce them to Category Theory concepts and see how small your solutions are. Firstly, it should be <em>possible</em> to solve those problems using Category Theory. Secondly, your solutions should be orders of magnitude smaller than the usual solutions.</p>
<p>See how Category Theory can help you do composition to reduce the complexity.</p>
<h1 id="notes">Notes</h1>
<ul>
<li><p>Thanks to <a href>Gabriel Gonsalez</a>’s brilliant blog posts for getting me fired up about Category Theory. All I know about Compositional Programming, I learnt from him.</p></li>
<li><p>The <code>greatGrandChildren</code> example is from Gabriel’s <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">Category Design Pattern</a> post.</p></li>
</ul>

<div class="info">Created: December 20, 2014</div>
<div class="info">Last modified: January 22, 2015</div>
<div class="info">Status: finished</div>
<div class="info"><b>Tags</b>: category theory, thinking</div>

<div id="sequence-navigation" style="text-align: right">
  <p>Part of <a href="../sequences.html"><i>No Sequence</i></a>

  <p>Previous post: &quot;<a href>Start of Sequence</a>&quot;

  <p>Next post: &quot;<a href>Head of Sequence</a>&quot;
</div>

<br />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'spkrationalitytrainingground'; // required: replace example with your forum shortname
    var disqus_identifier = '/Why-Category-Theory.html';
    var disqus_title = 'Why Category Theory';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
	var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
