<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<link rel="icon" type="image/png" href="./images/favicon-32x32.png" sizes="32x32" />
	<link rel="icon" type="image/png" href="./images/favicon-16x16.png" sizes="16x16" />
        <title>CS503 OS HW1 Notes - SPK's Rationality Essays</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/highlight.css" />

	<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> -->
	<!-- <script type="text/javascript" src="/js/header-links.js"></script> -->
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

	<link href="atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed" />

	<!-- Google Analytics stuff -->
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-51321929-1', 'pradeep90.github.io');
	  ga('send', 'pageview');

	</script>

    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Rationality Essays</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./notes.html">Notes</a>
                <!-- <a href="/about.html">About</a> -->
                <a href="./archive.html">Archive</a>
		<a href="./atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM/RSS Feed">RSS</a>
            </div>
        </div>

        <div id="content">
          <h1 id="post-title">CS503 OS HW1 Notes</h1>

            <!-- <center><img src="https://fbcdn-sphotos-d-a.akamaihd.net/hphotos-ak-prn1/t31.0-8/p600x600/10257116_10202295769100492_2438594605053717342_o.jpg" height="400" width="300" class="sujeet-pic" alt="Sujeet pic" /></center> -->

<h1 id="compiling-and-running-xinu">Compiling and running XINU</h1>
<p>After making changes,</p>
<pre><code>cd xinu-fall2017/compile
make clean
make rebuild
make</code></pre>
<p>You can edit remote files on your laptop’s Emacs using Tramp:</p>
<pre><code>/ssh:yourusername@xinu21.cs.purdue.edu:/homes/yourusername/</code></pre>
<p>To run on the backend:</p>
<pre><code>cd ~/xinu-fall2017/compile
cs-console
&lt;C-space&gt;
g (download default image - xinu - and powercycle backend)</code></pre>
<p>Test: Check if you can recompile and reload the xinu without logging off the backend.</p>
<p>Observation: Yes you can! Simply keep the backend connection open while you edit and recompile to your heart’s content. When you’re done, press <C-space> and g to powercycle.</p>
<h1 id="xinu-explorations">XINU Explorations</h1>
<pre><code>find . -type f -name &quot;*.c&quot; | wc -l

227

find . -type f -name &quot;*.c&quot; | xargs wc -l

...

21868 total</code></pre>
<p>Hmm… That seems pretty small.</p>
<h1 id="tags">TAGS</h1>
<p>Create tags using</p>
<pre><code>find . -name &quot;*.[chS]&quot; -print | etags -</code></pre>
<h1 id="understanding-xinu">Understanding XINU</h1>
<p>system/initialize.c: TODO</p>
<p>system/resched.c:</p>
<p>It just looks for the highest priority process and schedules it.</p>
<h2 id="ready">ready</h2>
<p>ready() inserts the process into readylist and then reschedules.</p>
<h2 id="startup">Startup</h2>
<p>nulluser() sets up the system and then creates the startup() process. After that, nulluser just runs in an infinite loop.</p>
<h2 id="main">main</h2>
<p>pid seems to be 3. How?</p>
<p>When I create a shell, pid 2 seems to be <code>rdsproc</code>. It’s created when initializing devices in sysinit(), which is called by nulluser.</p>
<h2 id="sleepms">sleepms</h2>
<p>It inserts itself in the sleep queue, sets state as sleep, and calls resched.</p>
<h2 id="sleepq---delta-list">sleepq - delta list</h2>
<p>sleepq is stored as a delta list, where each entry has its key as its delay from its previous entry. The benefit is that you can propagate changes cheaply. So, if you have three processes that need to be woken up in 3, 4, and 6 ms respectively, you will store it as 3, 1, 2. Then, upon each clock tick, you will decrement the first entry alone. And when the first element reaches 0, you can remove it and any elements after it that have 0 (recursively).</p>
<h2 id="clkhandler">clkhandler</h2>
<p>It’s called by clkdisp after disabling interrupts. So, when it calls resched, the process won’t get preempted.</p>
<h2 id="ctxsw">ctxsw</h2>
<p>I think it restores the interrupt mask (that may have been disabled by clkdisp when calling clkhandler).</p>
<h2 id="resched_cntl">resched_cntl</h2>
<p>Need to disable interrupts before calling resched or resched_cntl. Otherwise, you may get preempted and rescheduled in the middle of your resched call.</p>
<h2 id="preempt">preempt</h2>
<p>Assertion that worked (for my test case): processticks == QUANTUM (used full time slice) or processticks = QUANTUM - preempt (voluntarily gave up CPU).</p>
<h1 id="approach-rapid-prototyping">Approach: Rapid Prototyping</h1>
<p>Hypothesis: Add one feature at a time, in line with rapid prototyping. You’d have to release - aka run tests - after every feature.</p>
<p>Question: What tests?</p>
<p>Hypothesis: Minimum test - The kernel should type-check, compile, and boot up fine.</p>
<p>Hypothesis: Sufficient test - the ratio of process times for the proportional share scheduler should be in proportion to their priorities. (Add debug code to the scheduler function.)</p>
<p>Observation: This is an integration test, not a unit test. Expensive.</p>
<h1 id="approach-documentation-and-assertions">Approach: Documentation and Assertions</h1>
<p>Hypothesis: Document each function -&gt; categorize XINU appropriately.</p>
<p>Hypothesis: Use assertions -&gt; can unit test your code.</p>
<h1 id="hw1---understanding-the-instructions">HW1 - Understanding the Instructions</h1>
<p>XINU default scheduling invariant - current process is always the highest process one (round-robin among the processes with the high priority).</p>
<p>resched - pick one group using the aging scheduler, then pick a process from that group.</p>
<p>Aging scheduler - Default priority - 10. Changed via chgprio(). During each resched call, set the group priority of the current process’ group to its initial priority. Increment priority of each group by its count in the ready list (excluding the null process). Pick the group with highest priority. In a tie, pick proportional share scheduler. If no processes in one group, pick the other.</p>
<p>Aging scheduler in words - update group priorities, return next group.</p>
<p>Overall scheduler in words - update current process priority; get next group; if invalid group, schedule null (it will be the only thing in readylist); update process with highest priority; switch to it (if needed).</p>
<p>Proportional share scheduler in words - get best propsched guy in readylist; if none such or if current process is better (and in propsched), resched current process; else, evict current process; get quantum for best process; schedule best process;</p>
<p>TS scheduler in words - get best tssched guy in readylist; if none such or if current process is better (and in tssched), resched current process; else, evict current process; get quantum for best process; schedule best process.</p>
<hr />
<p>Proportional share scheduler - Initial Pi for each process = 0. When a rescheduling occurs, Pi of currently running process = Pi + (t * 100 / Ri). Process scheduled for the first time or after blocking, Pi = max(Pi, T). T is the number of ticks since the start of the system.</p>
<p>Scheduled after blocking: resume a process that is suspended (by default, the only time this happens is when you create() a process) - this calls ready anyway; ready a sleeping process;</p>
<p>Need to find process with minimum priority <em>within</em> proportional share group. For that, we need the “first key” in the PS ready list to compare against the current process.</p>
<p>TS scheduler - classify as CPU-bound or IO-bound. preempt &lt;= 0 =&gt; CPU-bound. Set priority and per-process quantum as per dispatch table.</p>
<p>Test: Both types of processes - set QUANTUM to a high value so that PS has a chance.</p>
<h1 id="course-questions">Course Questions</h1>
<p>What if you pass in a stack size to create() that is too small?</p>
<p>Do we have to disable interrupts when dealing with procent?</p>
<p>kputc - maybe enable interrupts anyway? What if somebody else calls kputc?</p>
<h1 id="hw1">HW1</h1>
<p>Hypothesis: sendA, sendB with priority 20 each - You switch from A to B, but not because A was eligible, but rather because it gave up the processor (probably for I/O). Ditto for B to main. However, main is pushed out because it used up its time quantum.</p>
<p>Observation: sendA, sendB with priority 25 each - again, main comes up only because A and B get blocked.</p>
<p><strong>Hypothesis</strong>: I’m not thinking of the type signature. That is: what question do I want to answer right now?</p>
<p>Question: Does main create A and B and then give up control later, or does A take up control right away and then give it to B only when finished?</p>
<p>Observation: I want labels (“main finishes first and then gives way to the new processes”), not raw data.</p>
<p><strong>Observation</strong>: main creates A and switches immediately (by design, I think). A blocks. main then creates and switches to B.</p>
<p>Question: Can a process keep hogging the CPU?</p>
<p>Observation: main creates A. A never gives up.</p>
<p>Observation: Infinite loop - no resched messages.</p>
<p>Hypothesis: So, A never even called resched. [wrong]</p>
<p>Question: Is resched called when A is in the infinite loop? Is preempt doing anything?</p>
<p>Observation: Yes. Over and over. There simply is nothing that is even equal in priority to A in the readylist.</p>
<p>Observation: Same priority - A and B and main go round and round.</p>
<p>Corollary: That explains why my loop of processes actually led to sequential execution. Each one was the only king during its execution.</p>
<p>Observation: main - when it resumes a process, it inadvertently calls resched, so it has to wait its turn before it can resume the next process.</p>
<p>Observation: If the processes have priority 15, they never get executed.</p>
<p>Observation: Processes with priority 20, main goes down to 15 after creating them - they go round-robin.</p>
<p>Observation: division by zero - because procrate was zero for the default processes.</p>
<p>Observation: Negative priorities because I used INT_MAX instead of <code>SHRT_MAX</code>.</p>
<p>Observation: Still, priority becomes negative for everybody.</p>
<p>Observation: Delta seems to be around 9420 for each process.</p>
<p>Hypothesis: Process ticks aren’t reset when they’re rescheduled.</p>
<p>Observation: Initial priority is 15 and quickly goes down to zero.</p>
<p>Hypothesis: Setting the initial priority in create() will fix things.</p>
<p>Observation: main - when relinquishing the processor, its process ticks counter isn’t reset.</p>
<p>Observation: new process - stays in the processor =&gt; not rescheduled; need to reset ticks here too.</p>
<p>Observation: Delta seems reasonable now.</p>
<p>Observation: Starting priority is actually still 15, because I’m calling <code>propsched_initialize_prio()</code> before create sets the initial priority.</p>
<p>Observation: Starting priority is correct. main gets kind of starved because 4 and 5 lose priority very slowly.</p>
<p>Observation: My benchmark isn’t working well. Processes are not all up at the same time.</p>
<p>Hypothesis: Why not try a different kind of benchmark?</p>
<p>Observation: main’s initial rate is 1, so that reduces its priority a lot in the first few rounds.</p>
<p>Observation: Ticks aren’t the total ticks.</p>
<p>Observation: Total ticks! So, my processtotalticks change probably did the trick.</p>
<p>Observation: Unexpected output - percentage rate gave the same output as same rate.</p>
<p>Observation: Wow. That was for the dumbest reason ever. I had never used the get_rate function!</p>
<p>Observation: Trying to see the percentage of process ticks during the benchmark. Failing badly. Taking a lot of time too.</p>
<p>Observation: I documented each function in Servo. Haven’t done that for XINU.</p>
<p>Observation: Confusing debug output - one of main’s update priority debug sets are split for some reason.</p>
<p>Observation: main gets preempted in the middle of stopping deferral.</p>
<p>Observation: main and the processes get to print one line before they get preempted!</p>
<p>Observation: However, resched itself doesn’t get preempted. Prints line after line!</p>
<p>Observation: One call to kprintf seems to take a time slice (2ms).</p>
<p>Observation: Wow. All because I didn’t disable interrupts before calling resched_cntl. 2.5 hours gone, just for that one lesson.</p>
<p>Observation: After implementing PS for a returning blocked process - main runs and sleeps, process 4 runs, but nothing else does.</p>
<p>Observation: Didn’t even call print_readylist.</p>
<p>Observation: Called <code>propsched_set_prio_after_blocking</code> <em>after</em> inserting into the readylist (on the key of the old priority).</p>
<p>Observation: Seems to work.</p>
<p>Observation: Calling newqueue() seems to cause a problem.</p>
<p>Observation: NQENT is the problem!</p>
<p>Observation: Fucked up a get max element in linked list because I didn’t update the curr pointer. Infinite loop.</p>
<p>Lesson: Clean and build when you change header files or <code>#define</code>s.</p>
<h1 id="hw2">HW2</h1>
<h2 id="understanding-the-instructions-interface-for-every-function">Understanding the Instructions: Interface for Every Function</h2>
<p>In a separate shellutils.c and piputils.c file:</p>
<p>shell - interpret command: bunch of tokens -&gt; Maybe tokens for processes in pipe order</p>
<p>shell - make processes: tokens for processes in pipe order -&gt; Maybe processes in pipe order</p>
<p>piputil - pipe together a bunch of processes: processes in pipe order -&gt; Maybe processes piped together</p>
<p>syscall - set stdout for process: process, stdout file descriptor -&gt; Maybe set stdout</p>
<p>syscall - set stdin for process: process, stdin file descriptor -&gt; Maybe set stdin</p>
<p>shell - clean up a command: kill all processes and their pipes -&gt; Maybe ok.</p>
<p>Test: overall - command with no pipes (see if you can programmatically run this from main); one pipe between different types of commands (producer blocks, consumer blocks, both block, some die or sleep or don’t get scheduled); multiple pipes</p>
<p>Refactor shell to make it use the above interface even for non-pipe commands. Make sure it works for the default case.</p>
<hr />
<p>pipinit: pipid [, Maybe pipe_t] -&gt; initialized pipe</p>
<p>pipglobalinit: globals {table} -&gt; initialized globals {table with everything set to free}</p>
<p>pipcreate: () [table] -&gt; Maybe did32, owner (then pipinit that pipe); table should have an active pipe at did32</p>
<p>pipdelete: pipe [, table] -&gt; ok; reset pipe state (maybe via pipinit or some pipreset they both call that clears the buffer and resets semaphores, etc.); check for owner; basically pipdisconnect.</p>
<p>pipconnect: pipe [, pipe struct], writer, reader -&gt; Maybe A and B piped; reader and writer should not be the same</p>
<p>pipdisconnect: pipe [, table, pipe struct] -&gt; Maybe ok (call set stdout with console);</p>
<p>pipputc: pipe [, pipe struct], char -&gt; Blocking ok</p>
<p>pipwrite: pipe [, pipe struct], buf, length -&gt; Blocking (number of characters or SYSERR); if pipe not in connected state or if this is not writer, return SYSERR; full -&gt; block; some space -&gt; write and block;</p>
<p><strong>TODO</strong>: Question: pipwrite - suppose reader doesn’t accept any more characters - return SYSERR or number of characters written?</p>
<p>pipgetc: pipe [, pipe struct] -&gt; Blocking (character or SYSERR)</p>
<p>pipread: pipe [, pipe struct], buf, length -&gt; Blocking (number of bytes read or SYSERR)</p>
<p><strong>TODO</strong>: Question: pipread - if no data, block; if only some data, read some bytes and block; if writer stops writing, return number of bytes read or SYSERR?</p>
<p>kill: process [, pipe struct] -&gt; delete pipes that you own; disconnect from any pipes (and disconnect the other process too)</p>
<hr />
<p>Question: How to go for refactor-red-green-refactor?</p>
<p><strong>Hypothesis</strong>: Get an interface for each function and then minimize it. Be strict - don’t touch anything outside the interface. Then test your implementation against it.</p>
<p>Test the different states of the pipe, producer, consumer, and owner (such as current, ready, sleeping, waiting, or free).</p>
<h2 id="implementation">Implementation</h2>
<p><strong>Hypothesis</strong>: Assert preconditions and postconditions. Argument testing - null, etc.</p>
<h2 id="information-from-interpreter">Information from Interpreter</h2>
<p>Observation: Added the pip32 &lt;-&gt; did32 utility functions</p>
<p>Observation: Don’t know which functions will call pipreset. Confused about how it should really behave.</p>
<p>Hypothesis: Go with separate functions and then merge them during refactor.</p>
<p>Observation: I don’t have any tests right now, red or green.</p>
<p>Hypothesis: Test all branches of your function.</p>
<p>Observation: <strong>RED</strong>! I hadn’t even run my test function.</p>
<p>Hypothesis: Unit tests (that failed and now pass) tell you that you’re making progress.</p>
<p><strong>Observation</strong>: I couldn’t run multiple tests on pipes because I hadn’t implemented pipdelete.</p>
<p>Observation: Bug - pipcreate returned did not pipid.</p>
<p>Observation: Ditto for pipinit.</p>
<p>Hypothesis: Need to add assertions everywhere I receive pipid. (You can say that again.)</p>
<p>Observation: pipdelete test passes without any implementation! Colour me shocked!</p>
<p><strong>Hypothesis</strong>: When refactoring before adding a feature, I need to assert preconditions and postconditions (or add unit tests) for everything the feature changes. Worst case, I need to catch those after adding the feature.</p>
<p>Hypothesis: Bug due to did32 vs pipid32 &lt;- my confusion about the two types.</p>
<p>Hypothesis: That feels like duplication of code. Wait. It is! Why do you have two different types for the same value! One should be a view of the other - a simple function somewhere.</p>
<p>Observation: All my time so far was spent debugging because of a simple type confusion.</p>
<p><strong>Observation</strong>: Always, always, always make a test fail before you make it pass.</p>
<h1 id="os-hw3">OS HW3</h1>
<h2 id="problem-statement">Problem Statement</h2>
<p>Overview</p>
<p><strong>TODO</strong>: Read Intel manual volume 3, chapters 2-5</p>
<h3 id="virtual-memory-services">Virtual Memory Services</h3>
<p>vcreate: process must have a private heap with hsize pages.</p>
<p>vgetmem: given a private heap, ask for memory -&gt; get it.</p>
<p>vfreemem: given a private heap, free memory -&gt; free it up.</p>
<p>Two types of heaps: normal public heap; private virtual heap. You should be able to switch between the two.</p>
<p>srpolicy: set page replacement function.</p>
<h3 id="backing-stores-and-memory-management">Backing Stores and Memory Management</h3>
<p>We need virtual memory to extend the memory of the machine using disk space or SSD.</p>
<p>rdserver is simply the secondary storage from where we will read or write pages.</p>
<p>Question: How many backing stores do you need? Is it that when one is blocked and a process demands another page, we have to use the next one?</p>
<p>read_bs is a way to read pages instead of blocks from a backing store. That backing store could be on QEMU or on a real RDISK, based on the value of WRDISK.</p>
<h3 id="using-the-paging-server-api">Using the Paging Server API</h3>
<p>No need to run rdserver when using QEMU.</p>
<p>Need to run rdserver on the XINU frontend machine.</p>
<h3 id="memory-layout">Memory Layout</h3>
<blockquote>
<p>1024 pages starting at memory address 0x90000000 are used for device memory (Ethernet and Console) and must be mapped at the same physical address. Hence, the first four page tables and the page table for device memory for every process will be the same, i.e. they are shared/global.</p>
</blockquote>
<blockquote>
<p>Memory at page 4096 and above constitute a process019s private virtual memory. This private address space is visible only to the process that owns it. A process019s private heap is mapped somewhere in this area by vcreate().</p>
</blockquote>
<h3 id="page-tables">Page Tables</h3>
<blockquote>
<p>For Lab3, you will not be paging either the page directories or page tables. That is, page directories and page tables should not be relying on backing stores. For page directory, they must always be allocated. However, it is not practical to allocate all potential page tables for a newly created process. Therefore, to conserve memory, page tables are created on-demand. The first time a page is touched (i.e. it has been mapped by a process), a page table needs to be allocated.</p>
</blockquote>
<blockquote>
<p>Conversely, when a page table is no longer needed, it should be removed in order to conserve space.</p>
</blockquote>
<h3 id="page-fault-interrupt-service-routine-isr">Page Fault Interrupt Service Routine (ISR)</h3>
<blockquote>
<p>Check that a is a valid address, if not, print an error message and kill the process.</p>
</blockquote>
<blockquote>
<p>Using the backing store map, find the store s and page offset o which correspond to vp.</p>
</blockquote>
<h3 id="obtain-a-free-frame">Obtain a Free Frame</h3>
<h3 id="backing-store-map">Backing Store Map</h3>
<blockquote>
<p><pid, vpage, npages, store></p>
</blockquote>
<p>Question: Is vpage the starting page number and npages the number of pages numbers from there?</p>
<p>Question: How many backing stores? Divide total number of pages into 8? Or 2 stores per process?</p>
<blockquote>
<p>f(pid, vaddr) =&gt; (store, page_offset within store)</p>
</blockquote>
<p>Question: How can we find a page for every virtual address? There are 500k possible pages but only 205 pages available on the backing store.</p>
<p>(Maybe virtual heap will be small enough to fit within one or two backing stores.)</p>
<h3 id="inverted-page-table">Inverted Page Table</h3>
<p>Have reference count of frames - how many entries in this page table are present.</p>
<h3 id="private-heap">Private Heap</h3>
<blockquote>
<p>A separate mapping must be created for a new process’s private heap when created with vcreate().</p>
</blockquote>
<p>Question: What does that mean? Is it that the page directory for every process will map to the same identity address for page numbers 0-4096?</p>
<h3 id="prototypes">Prototypes?</h3>
<p>prototypes.h</p>
<h3 id="handling-error-code-on-page-fault">Handling error code on page fault</h3>
<p>https://piazza.com/class/j6dtteb9lor25u?cid=185</p>
<h3 id="memory-addressing">Memory Addressing</h3>
<p>http://pages.cs.wisc.edu/~remzi/OSTEP/vm-paging.pdf http://wiki.osdev.org/Paging http://wiki.osdev.org/Setting_Up_Paging</p>
<h2 id="assembly">Assembly</h2>
<p>Have to store the value in a global variable and then copy from that global variable to a local variable. (See stacktrace.c for an example - <code>g_esp</code> vs <code>sp</code>.)</p>
<p><strong>Question</strong>: Should I have a .S file for page fault interrupt service routine.</p>
<p>Question: Should I pop error code? But clkdisp.S doesn’t do that. (Going with “add $4, %esp iret” as per SO.)</p>
<p>Question: assembly - sti needed?</p>
<h2 id="page-fault-handler">Page Fault Handler</h2>
<p>Question: How to get the faulted address?</p>
<p>(Answer: CR2)</p>
<h2 id="context-switching">Context-Switching</h2>
<p>Question: Do we need to clear the TLB upon context switch?</p>
<p><strong>Important</strong>: Flush the TLB upon context-switch.</p>
<blockquote>
<p>As we switch context between processes, we must also switch between memory spaces. This is accomplished by updating the PDBR register with every context switch. This register must always point to a valid page directory that is in RAM at a page boundary.</p>
</blockquote>
<p>When you context-switch, you don’t need to clear TLB?</p>
<h2 id="implementation-plan">Implementation Plan</h2>
<p><strong>Hypothesis</strong>: Assert preconditions and postconditions. Argument testing - null, etc. Also, have a unit test for each branch.</p>
<hr />
<p><strong>TODO</strong>: Do we have to do a clean build whenever we change a #DEFINE constant?</p>
<h2 id="tests">Tests</h2>
<p>4 processes, 2 backing stores each</p>
<p>1 process, 8 backing stores</p>
<p>6 processes.</p>
<h2 id="observations">Observations</h2>
<p>When I tried setting page directory to NULL and enabled paging, the OS seemed to keep rebooting.</p>
<h2 id="questions">Questions</h2>
<p><strong>TODO</strong>: Explain whole process in your own words.</p>
<p>Question: hsize is 100 - allocate one backing store. 300? 10000? The process can access only that part (plus the global heap)?</p>
<p>Answer: heap size will be between 0 and 1600.</p>
<p>What if you try to give hsize as 1M? Isn’t that still possible using a limited number of frames, by constantly replacing pages? But isn’t it limited by the size of the backing store (1600 total pages)?</p>
<p><strong>Question</strong>: Divide the heap into parts across backing stores? 200 per store?</p>
<p>Answer: Yes.</p>
<p>Does the backing store look like this - pid 4, 0, 200, backing store 2; pid 5, 400, 100, backing store 1?</p>
<p>Question: allocate backing stores on startup? when a process wants to use a backing store, call open_bs? when a process is killed, call close_bs?</p>
<p><strong>Hypothesis</strong>: Allocate backing stores in vcreate. To use the backing store, open, read or write, close.</p>
<p>Question: One process per backing store, right? What is <code>usecount</code>?</p>
<p>Question: Virtual heap should be private - do we need to set access bits in the page directory or page table?</p>
<p><strong>Question</strong>: It seems to pass page replacement and page fault handling (when I use getmem in vgetmem). Why?</p>
<p>Question: How to access a random address in memory (given pages)? My initial example doesn’t seem to work.</p>

<div class="info">Created: September  9, 2017</div>
<div class="info">Last modified: December  1, 2017</div>
<div class="info">Status: in-progress notes</div>
<div class="info"><b>Tags</b>: notes, os</div>

<br />
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'spkrationalitytrainingground'; // required: replace example with your forum shortname
    var disqus_identifier = '/CS503-OS-notes.html';
    var disqus_title = 'CS503 OS HW1 Notes';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
	var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
